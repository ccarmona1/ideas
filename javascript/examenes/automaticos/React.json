[{"id":"q1","question":"Which of the following best describes the purpose of a custom React Hook and when would you primarily use one?","options":["a) To abstract stateful logic from a component, making it reusable across multiple components without prop drilling.","b) To create new lifecycle methods for functional components that mimic `componentDidMount` and `componentWillUnmount` simultaneously.","c) To enable class components to utilize state management provided by `useState` and `useEffect` hooks.","d) To directly manipulate the DOM outside of React's declarative approach, ensuring optimal performance for complex animations."],"answer":"a","explanation":"Custom Hooks are a powerful feature introduced with React Hooks to abstract and reuse stateful logic. By convention, they start with `use` and allow developers to encapsulate logic that might otherwise be duplicated across components, promoting code reusability and maintainability. They help avoid prop drilling by providing a clean way to share logic.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"While custom hooks can encapsulate effects that run on mount/unmount, their primary purpose is not to create new lifecycle methods but to abstract reusable logic. `useEffect` already handles mount/unmount scenarios.","c":"Hooks, including custom hooks, are specifically designed for functional components. Class components do not use `useState` or `useEffect` and cannot directly benefit from custom hooks in this manner.","d":"Directly manipulating the DOM outside of React's declarative paradigm is generally discouraged, especially for performance reasons, as it can conflict with React's reconciliation process. While `useRef` can grant access to DOM nodes, the core purpose of a custom hook is not for direct DOM manipulation but for logic abstraction."}},{"id":"q2","question":"Consider a scenario where a React component's state update triggers an extensive re-render of its large child tree, leading to performance issues. Which of the following optimization techniques is most appropriate and effective for mitigating this problem, assuming the child components are 'pure' (i.e., render solely based on their props and state)?","options":["a) Implement `React.memo` around the child components to prevent unnecessary re-renders if their props have not changed.","b) Use `useCallback` to memoize event handlers passed to the child components, ensuring referential equality across renders.","c) Refactor the component to use `shouldComponentUpdate` with a deep comparison for props and state in the parent.","d) Employ `useDeferredValue` to delay the re-rendering of the child tree until a more opportune time, improving perceived responsiveness."],"answer":"a","explanation":"`React.memo` is a higher-order component that memoizes a functional component, preventing it from re-rendering if its props have not changed. This is ideal for 'pure' components that are expensive to render and receive stable props. It directly addresses the problem of unnecessary re-renders in the child tree.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"`useCallback` memoizes functions (like event handlers), ensuring that their reference remains stable across renders. While this is important for `React.memo` to work effectively when functions are passed as props, it's not the primary mechanism for preventing the child component's re-render itself; `React.memo` is. Without `React.memo`, `useCallback` alone won't prevent the re-render if other props change or the component isn't memoized.","c":"`shouldComponentUpdate` is a lifecycle method for class components. While it serves a similar purpose to `React.memo` (preventing re-renders), the question implies a modern React context (often functional components due to Hooks), and deep comparison in `shouldComponentUpdate` can itself be very expensive, potentially negating the performance benefits if not implemented carefully.","d":"`useDeferredValue` is used to defer updating a part of the UI. It helps with perceived responsiveness by prioritizing urgent updates, but it doesn't prevent re-renders; it merely delays them. If the re-render is inherently expensive and unnecessary, deferring it doesn't solve the root cause, which is the re-render itself. `React.memo` prevents the re-render altogether when props are stable."}},{"id":"q3","question":"Explain the concept of 'concurrency' in React and how `startTransition` contributes to it.","options":["a) Concurrency in React allows the UI to remain responsive during heavy computations by rendering updates in the background. `startTransition` marks updates as 'transitions,' which are interruptible and don't block user interaction.","b) Concurrency refers to React's ability to execute multiple `useEffect` hooks simultaneously for performance optimization. `startTransition` ensures these effects are batched into a single render pass.","c) Concurrency is React's mechanism for pre-fetching data from multiple APIs in parallel to improve load times. `startTransition` prioritizes these data fetches based on user intent.","d) Concurrency enables React to run multiple instances of the same component in parallel within the same DOM tree. `startTransition` manages the synchronization of state between these instances."],"answer":"a","explanation":"React's concurrency features allow it to work on multiple tasks (e.g., rendering updates) simultaneously. This means it can interrupt a rendering task if a higher-priority update (like user input) comes in, keeping the UI responsive. `startTransition` is a key API that marks updates as 'transitions' (non-urgent updates). React can then defer or interrupt these transition updates to handle more urgent, interactive updates, ensuring a smoother user experience.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"Concurrency is not about executing `useEffect` hooks simultaneously, nor is `startTransition` about batching effects. Effect execution order and dependencies are managed by `useEffect` itself, and batching generally refers to grouping state updates.","c":"While data fetching is an important aspect of web applications, React's concurrency model isn't primarily about pre-fetching data from APIs. Its focus is on how rendering updates are scheduled and processed within the UI.","d":"React components always render within a single DOM tree. Concurrency doesn't allow multiple instances of the *same component* to run in parallel in the sense of independent DOM trees, nor does `startTransition` manage state synchronization in that manner. Its purpose is scheduling rendering work."}},{"id":"q4","question":"You are building a complex data visualization component in React that frequently updates. The rendering performance is critical, and you've noticed that `useEffect` hooks within the component are causing re-renders that block the main thread. How would you approach optimizing this, specifically targeting the impact of effects?","options":["a) Use `useLayoutEffect` for effects that need to read DOM layout, and ensure dependencies arrays are tightly controlled to minimize re-runs.","b) Offload heavy computations or DOM manipulations triggered by `useEffect` to a Web Worker, communicating results back via messages.","c) Employ `useReducer` instead of `useState` for state management within the effect, as it offers better performance for complex state logic.","d) Wrap the entire `useEffect` hook in `React.memo` to prevent its re-execution unless its dependencies change."],"answer":"b","explanation":"If `useEffect` is causing blocking re-renders due to heavy computations or direct DOM manipulations, moving that work to a Web Worker is a highly effective strategy. Web Workers run in a separate thread, preventing them from blocking the main UI thread and keeping the application responsive. Results can then be sent back to the main thread for React to update the DOM.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"`useLayoutEffect` runs synchronously after all DOM mutations but before the browser paints. While useful for DOM measurements, it still blocks the main thread. If an effect itself is causing blocking, switching to `useLayoutEffect` won't solve the blocking issue, it might even exacerbate it for long-running tasks. Tightly controlling dependencies is always good practice but doesn't solve the core issue of a *heavy* effect blocking.","c":"`useReducer` can be more performant than `useState` for complex state logic because it centralizes state transitions, but it doesn't inherently make the operations *within* `useEffect` less blocking or move them off the main thread. The blocking issue stems from the computation itself, not the state management mechanism used *inside* the effect's dependencies.","d":"`React.memo` is a Higher-Order Component used to memoize an entire functional component, preventing its re-render if props haven't changed. You cannot wrap a `useEffect` hook directly in `React.memo`. Hooks are functions that must be called inside a functional component."}},{"id":"q5","question":"What is the primary benefit of using Context API for state management over prop drilling, and when might it be an inappropriate choice for a complex application?","options":["a) Context API avoids prop drilling by providing a way to pass data deeply into the component tree without manually passing props at each level. It might be inappropriate for frequently updated, rapidly changing state due to potential re-renders across consumers.","b) Context API enables global state access for all components, making state mutation simpler. It's inappropriate when strict type checking of state is required, as it bypasses TypeScript's capabilities.","c) Context API automatically optimizes re-renders by only updating components that consume specific context values. It's inappropriate for small applications where prop drilling is more performant.","d) Context API provides a built-in immutable state management solution, preventing accidental mutations. It's inappropriate for applications requiring server-side rendering due to hydration issues."],"answer":"a","explanation":"The primary benefit of Context API is indeed to avoid 'prop drilling' â€“ the tedious process of passing props down through many levels of nested components when only a deeply nested child needs the data. However, Context is not a performance optimization tool. If a context value changes, *all* components consuming that context (even if they only use a small part of the value or are memoized without specific `selector` patterns) will re-render. For frequently updated, rapidly changing state that many components consume, this can lead to performance issues, making it a less ideal choice compared to dedicated state management libraries like Redux or Zustand that offer more granular re-render optimizations (e.g., selectors).","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"Context API provides global access, but it doesn't inherently make state mutation simpler; state management logic still needs to be built around `useState` or `useReducer` within the provider. Context works perfectly fine with TypeScript; it doesn't bypass type checking but rather integrates well with it by allowing you to define the type of the context value.","c":"Context API does *not* automatically optimize re-renders. As explained in the correct answer, a change in context value can cause all consumers to re-render. Prop drilling is often more performant for small applications or when data doesn't need to be passed very deeply, as it's explicit and React's reconciliation handles direct prop changes efficiently.","d":"Context API doesn't provide an immutable state management solution; that's up to the developer (e.g., using `useState` or `useReducer` with immutable updates). It also works seamlessly with Server-Side Rendering (SSR) through hydration; there are no inherent issues there. The context value is provided on the server and then re-hydrated on the client."}},{"id":"q6","question":"When building a React application, you encounter a situation where a child component needs to trigger an action in its parent component that involves updating the parent's state and potentially other side effects. What is the most idiomatic and recommended way to achieve this communication pattern in React?","options":["a) Pass a callback function from the parent to the child as a prop, which the child can then invoke to communicate with the parent.","b) Use `useRef` in the parent to get a direct reference to the child component instance and call a method on it.","c) Employ a global event bus (e.g., using `EventEmitter`) to publish events from the child and subscribe to them in the parent.","d) Utilize React Context API to expose a state setter function from the parent for the child to directly modify the parent's state."],"answer":"a","explanation":"Passing a callback function from the parent to the child as a prop is the most idiomatic and recommended way for child-to-parent communication in React. This pattern maintains a clear unidirectional data flow (props down, events up) and promotes component reusability and testability. The child component remains decoupled from the parent's internal state logic.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"While `useRef` can get a reference to a child component, directly calling methods on child components (especially functional ones using `useImperativeHandle`) is generally discouraged as it breaks the declarative nature of React and creates tight coupling, making components harder to reason about and refactor.","c":"A global event bus can be used for communication between distant components, but for parent-child communication, it's overkill and introduces unnecessary complexity and potential debugging challenges. It breaks the explicit data flow provided by props and callbacks, making it harder to trace where an event originates and where it's handled.","d":"While Context can expose state setters, using it solely for direct child-to-parent communication for individual actions is generally an over-engineering for this specific problem and can lead to less explicit data flow. Context is better suited for providing shared data or services that are consumed by many components deeply nested in the tree, not for simple immediate parent-child action communication. It also doesn't prevent over-renders if the setter itself is part of a frequently changing context value."}},{"id":"q7","question":"Explain the concept of 'suspense' in React, specifically how it addresses data fetching and the user experience for asynchronous operations.","options":["a) Suspense allows components to 'wait' for asynchronous data to be ready before rendering, automatically displaying a fallback UI (e.g., a loading spinner) during the wait, improving perceived performance and user experience.","b) Suspense is a mechanism for reactively updating the DOM when data changes in an external data store, eliminating the need for `useState` and `useEffect` for data synchronization.","c) Suspense optimizes network requests by batching multiple data fetches into a single request, reducing latency and server load.","d) Suspense provides a built-in caching layer for API responses, ensuring that previously fetched data is served instantly without re-fetching, thus speeding up subsequent renders."],"answer":"a","explanation":"Suspense is a React feature that lets your components 'wait' for something before they render. In the context of data fetching (when integrated with a Suspense-enabled data fetching library), it allows a component to 'suspend' its rendering while data is being fetched. During this suspension, React can render a fallback UI (like a loading indicator) defined by the nearest `<Suspense>` boundary above it in the tree, improving the perceived performance and providing a smoother user experience by preventing janky loading states.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"Suspense is not a replacement for `useState` or `useEffect` for general data synchronization. It's specifically for managing the *rendering* of asynchronous operations, not for eliminating explicit state management for data. It works *with* data fetching libraries that integrate with Suspense, rather than being a standalone data store updater.","c":"Suspense itself does not batch network requests or optimize them in that manner. Its role is purely in the rendering and UI management of asynchronous operations. Network request optimization is typically handled by the data fetching library or the network layer (e.g., GraphQL batching).","d":"While some data fetching libraries that integrate with Suspense might include caching, Suspense itself is not a caching layer. Its core functionality is about orchestrating the rendering of loading states for asynchronous operations. Caching is a separate concern, though often related to improving the performance of data fetching."}},{"id":"q8","question":"You are debugging a complex React application and observe that a functional component re-renders excessively, even when its props or state appear unchanged. You've already tried `React.memo` on the component but it's not having the desired effect. What could be a likely cause, and how would you investigate it?","options":["a) The component is receiving new function references (e.g., event handlers or callbacks) as props on every parent re-render, breaking `React.memo`'s shallow comparison. Use `useCallback` for these functions.","b) The component's internal state is being mutated directly, bypassing `useState`'s setter. Use `useReducer` to ensure immutable updates.","c) The component is consuming a React Context that updates frequently, and `React.memo` does not prevent re-renders caused by context changes. Use `useMemo` for context values.","d) The browser's dev tools are misreporting re-renders due to a caching issue. Clear browser cache and re-run the application."],"answer":"a","explanation":"`React.memo` performs a shallow comparison of props. If a parent component re-renders, and it passes new function references (e.g., a new anonymous function for an event handler) as props to a memoized child, `React.memo` will detect a prop change and re-render the child, even if the underlying logic of the function is the same. The solution is to use `useCallback` in the parent component to memoize these function references, ensuring they remain stable across re-renders unless their dependencies change.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"While direct state mutation is a common mistake and can lead to unexpected behavior, it typically wouldn't cause *excessive* re-renders when a component's props/state *appear* unchanged *after* `React.memo` is applied. If state is mutated directly, React might not even detect a change, leading to *no* re-render, or an inconsistent state. `useReducer` encourages immutable updates but doesn't specifically address the `React.memo` bypass.","c":"It's true that `React.memo` does not prevent re-renders caused by context changes; *all* consumers of a context will re-render if the context value changes. However, `useMemo` is used to memoize values, not context itself. If the context itself is the issue, options might involve splitting the context, using selectors (if available in a state management library built on context), or ensuring the context provider's value is stable (e.g., by memoizing the object passed as `value`). But the most common specific reason for `React.memo` failure is unstable prop references.","d":"While browser issues can occur, it's highly unlikely that dev tools would consistently misreport re-renders for a specific component across multiple runs due to caching. This is a common and well-understood performance pitfall in React development."}},{"id":"q9","question":"Explain the concept of 'server components' (RSC) in React and their primary benefit compared to traditional client-side components.","options":["a) Server Components render exclusively on the server and never hydrate on the client, primarily used for static content generation and reducing client-side bundle size.","b) Server Components allow developers to render components on the server and stream them to the client, combining server-side logic and data fetching with interactive client-side components, significantly reducing initial load times and client-side JavaScript.","c) Server Components are a replacement for backend APIs, enabling direct database queries from React components without needing a separate API layer, simplifying full-stack development.","d) Server Components provide a secure sandboxed environment for sensitive business logic, preventing it from being exposed to the client-side JavaScript bundle."],"answer":"b","explanation":"React Server Components (RSC) are a new paradigm that allows developers to render components on the server and stream them to the client. Their primary benefit is reducing the amount of JavaScript sent to the client, leading to faster initial page loads and improved performance. They can seamlessly interleave with client components, allowing interactive parts to hydrate while static parts remain on the server, combining the best of both server and client rendering.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"While Server Components reduce client-side bundle size and can be used for static content, they are not exclusively for static content and can include dynamic data. More importantly, they are designed to *integrate* with client components, with parts of the tree being client-side and hydrating, enabling interactivity.","c":"Server Components are not a replacement for backend APIs. While they can perform direct data fetching on the server, they still rely on existing database/API infrastructure on the server. They abstract the data fetching *within* the component model, but don't eliminate the need for a robust backend system.","d":"While Server Components do keep server-side logic off the client, making it more secure in terms of not exposing internal logic, their primary benefit is performance and client-side bundle size reduction, not solely security sandboxing. Security is a positive side effect but not the main driver."}},{"id":"q10","question":"You are designing a reusable component library in React. How would you ensure that your components are flexible enough to accept and render arbitrary child elements, potentially including other React components, HTML elements, or plain text, without explicitly defining props for each possible type of content?","options":["a) Utilize the `children` prop, which is a special prop that automatically passes whatever is nested between the opening and closing tags of a component directly to its rendering logic.","b) Define a prop named `content` with a type of `React.ReactNode` in TypeScript, and explicitly render it within the component's JSX.","c) Implement a higher-order component (HOC) that dynamically injects child elements based on a configuration object passed as a prop.","d) Use `dangerouslySetInnerHTML` to inject arbitrary HTML strings into the component, as this provides maximum flexibility for content."],"answer":"a","explanation":"The `children` prop is the standard and most idiomatic way in React to allow components to accept and render arbitrary content nested within their opening and closing tags. Whatever you put between `<MyComponent>` and `</MyComponent>` becomes the value of the `props.children` property, which can then be rendered directly within the component's JSX.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"While defining a prop `content` with type `React.ReactNode` is good for type safety, and you *could* use a prop for content, it's not the idiomatic way for nested content. The `children` prop is specifically designed for this pattern and offers a more natural, readable JSX syntax for consumers of the component.","c":"A higher-order component (HOC) is used to transform or enhance components by wrapping them. While powerful, using an HOC solely for dynamically injecting children based on a config object is overly complex and not the standard solution for handling general nested content. The `children` prop handles this natively and simply.","d":"`dangerouslySetInnerHTML` should be avoided whenever possible, as its name suggests. It allows injecting raw HTML strings, which can expose your application to cross-site scripting (XSS) vulnerabilities. It's reserved for rare cases where you absolutely trust the HTML source and need to render it directly, not for rendering arbitrary React elements or text. It breaks React's declarative model and reconciliation."}}]