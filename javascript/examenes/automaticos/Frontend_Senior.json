[{"id":"q1","question":"¿Cuál es la principal ventaja de usar React Server Components (RSC) en una aplicación React para un senior frontend?","options":["a) Reducción significativa del JavaScript enviado al cliente y mejor rendimiento inicial.","b) Permite la ejecución de código Node.js directamente en el navegador del cliente.","c) Facilita la creación de aplicaciones monolíticas con React y Express.","d) Elimina la necesidad de usar Redux o cualquier otro gestor de estado."],"answer":"a","explanation":"Los React Server Components (RSC) son una característica innovadora que permite renderizar componentes en el servidor, reduciendo la cantidad de JavaScript enviada al cliente. Esto mejora drásticamente el rendimiento inicial de la aplicación (Time To Interactive) y la experiencia de usuario, especialmente en dispositivos con conexiones lentas o limitaciones de hardware. Además, permite acceder a recursos de backend directamente desde los componentes, eliminando la necesidad de APIs intermedias para cierta lógica de datos.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"Los RSC no ejecutan Node.js en el navegador del cliente; se ejecutan en el servidor. El navegador recibe solo el HTML y un mínimo JavaScript para la interactividad.","c":"Si bien RSC se integra bien con frameworks como Next.js que facilitan aplicaciones full-stack, su propósito principal no es la creación de monolitos per se, sino la optimización del rendimiento y la experiencia de desarrollo a través de la renderización en el servidor.","d":"Aunque RSC puede reducir la necesidad de soluciones de estado global para ciertos escenarios de datos que se manejan en el servidor, no elimina por completo la necesidad de gestores de estado para el estado de UI o el estado del cliente que requiere interactividad compleja."}},{"id":"q2","question":"¿Cómo se aborda la seguridad XSS (Cross-Site Scripting) de forma efectiva en React, más allá de la sanitización básica?","options":["a) Utilizando `dangerouslySetInnerHTML` con datos provenientes de fuentes no confiables.","b) Dependiendo únicamente de Content Security Policy (CSP) con una política laxista.","c) Implementando un saneador de HTML robusto en el lado del cliente y asegurando que React escape automáticamente el contenido por defecto.","d) Deshabilitando la ejecución de scripts en el navegador del usuario a través de encabezados HTTP."],"answer":"c","explanation":"React, por defecto, escapa automáticamente el contenido de las variables que se renderizan, lo que previene la mayoría de los ataques XSS. Sin embargo, para escenarios donde se debe renderizar HTML directamente (por ejemplo, desde un editor WYSIWYG), es crucial utilizar un saneador de HTML robusto (como `DOMPurify`) para limpiar el contenido antes de usar `dangerouslySetInnerHTML`. Complementar esto con una CSP bien configurada (no laxa) añade una capa extra de defensa.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Utilizar `dangerouslySetInnerHTML` con datos no sanitizados o de fuentes no confiables es precisamente la forma de abrir una vulnerabilidad XSS. React expone esta API como un escape, pero su nombre advierte sobre los peligros.","b":"CSP es una herramienta poderosa, pero una política laxista (por ejemplo, permitiendo 'unsafe-inline' o 'unsafe-eval') anula su propósito de seguridad y deja la aplicación vulnerable a XSS. Además, no es la única defensa, sino una capa adicional.","d":"Deshabilitar la ejecución de scripts en el navegador del usuario no es una opción viable ni práctica para una aplicación web interactiva moderna. La funcionalidad de una aplicación React depende fundamentalmente de JavaScript. Los encabezados HTTP pueden ayudar con CSP, pero no deshabilitan scripts arbitrariamente."}},{"id":"q3","question":"Un senior frontend está diseñando una arquitectura de micro-frontends. ¿Cuál es un desafío clave relacionado con la comunicación y el estado compartido entre micro-frontends?","options":["a) La imposibilidad de reutilizar componentes de React entre diferentes micro-frontends.","b) La gestión del aislamiento del DOM y los estilos entre micro-frontends.","c) La coordinación de eventos, la sincronización del estado y el manejo de rutas compartidas.","d) El excesivo tamaño de los bundles JavaScript debido a la duplica de dependencias."],"answer":"c","explanation":"En arquitecturas de micro-frontends, uno de los desafíos más complejos es cómo los diferentes micro-frontends (que pueden ser desarrollados por equipos distintos y en tecnologías distintas) se comunican entre sí, comparten estado de forma consistente y gestionan las rutas sin interferir. Esto a menudo requiere patrones como pub/sub a través del navegador, APIs de comunicación directa o un enrutador centralizado.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"La reutilización de componentes es posible a través de librerías de componentes compartidas o monorepos, aunque requiere una buena estrategia de gestión de dependencias.","b":"Si bien el aislamiento de DOM y estilos es un desafío (soluciones como Shadow DOM o CSS-in-JS con alcance son comunes), la comunicación y el estado son problemas de mayor abstracción y complejidad arquitectónica.","d":"El tamaño de los bundles es una preocupación válida y un desafío en micro-frontends (especialmente por la duplicación de librerías), pero las técnicas de optimización como Module Federation o la deduplicación de dependencias pueden mitigarlo. No es tan fundamental como la comunicación entre ellos."}},{"id":"q4","question":"¿Qué patrón arquitectónico es más adecuado para gestionar el estado global persistente y complejo en una aplicación React a gran escala, considerando rendimiento y mantenibilidad?","options":["a) Context API con `useReducer` para cada componente que lo necesite.","b) Redux Toolkit con RTK Query para la gestión de estado de servidor y cliente.","c) Levantamiento de estado (lifting state up) al componente raíz para todo el estado de la aplicación.","d) Usar solo `useState` y `useEffect` en cada componente para su estado local."],"answer":"b","explanation":"Redux Toolkit con RTK Query es una solución robusta y moderna para la gestión de estado en aplicaciones a gran escala. RTK Query abstrae gran parte de la lógica de fetching, caching y sincronización de datos del servidor, mientras que el resto de Redux Toolkit proporciona herramientas para gestionar el estado del cliente de forma predecible y escalable. Esto reduce el boilerplate y mejora la mantenibilidad.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Context API es adecuado para estado global no excesivamente complejo o que no requiere actualizaciones frecuentes en muchos puntos, ya que re-renderiza todos los consumidores ante un cambio. Usarlo indiscriminadamente para todo el estado global complejo puede llevar a problemas de rendimiento.","c":"Levantar todo el estado al componente raíz hace que el componente raíz sea extremadamente pesado y propenso a re-renderizados innecesarios, impactando el rendimiento. Es inviable para aplicaciones grandes.","d":"Usar solo `useState` y `useEffect` es excelente para el estado local de componentes, pero no es escalable para gestionar estado global compartido y persistente en una aplicación grande, ya que llevaría a 'prop drilling' y dificultades para la sincronización."}},{"id":"q5","question":"En el contexto de las 'últimas tecnologías' en frontend, ¿cuál es la principal mejora que WebAssembly (Wasm) ofrece a las aplicaciones web?","options":["a) Permite ejecutar JavaScript de forma más eficiente en el navegador.","b) Facilita la creación de interfaces de usuario interactivas con menos código.","c) Ofrece rendimiento casi nativo para cargas de trabajo computacionales intensivas, expandiendo las capacidades del navegador.","d) Reemplaza completamente a HTML, CSS y JavaScript para el desarrollo web."],"answer":"c","explanation":"WebAssembly (Wasm) es un formato de instrucción binario de bajo nivel para una máquina virtual basada en pilas. Su principal ventaja es que permite ejecutar código compilado desde otros lenguajes (C++, Rust, Go, etc.) en el navegador con un rendimiento cercano al nativo. Esto es ideal para aplicaciones que requieren cálculos intensivos, juegos 3D, edición de video o simulaciones complejas, expandiendo significativamente las capacidades de lo que se puede hacer en el navegador.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Wasm no ejecuta JavaScript de forma más eficiente; es un lenguaje de bajo nivel independiente diseñado para complementarlo, no reemplazarlo. JavaScript sigue siendo el lenguaje principal para la mayoría de las operaciones del DOM.","b":"Wasm no está directamente diseñado para la creación de UI interactivas con menos código. Su enfoque es el rendimiento computacional. Las librerías de UI (como React) siguen siendo necesarias para construir interfaces de usuario de manera eficiente.","d":"Wasm está diseñado para ser un complemento a las tecnologías web existentes (HTML, CSS, JavaScript), no un reemplazo. Trabaja en conjunto con JavaScript y el DOM, y no es adecuado para reemplazar directamente HTML o CSS."}},{"id":"q6","question":"¿Cómo contribuye el 'Server-Side Rendering' (SSR) en React a mejorar la seguridad de una aplicación?","options":["a) Evita que el cliente acceda a los datos sensibles que se procesan en el servidor.","b) Elimina por completo la superficie de ataque para vulnerabilidades del lado del cliente como XSS y CSRF.","c) Permite el uso de autenticación basada en JWT que es intrínsecamente más segura.","d) Mejora la seguridad al generar el HTML final en el servidor, limitando la exposición de scripts y datos en el navegador antes de la hidratación."],"answer":"d","explanation":"SSR contribuye a la seguridad al renderizar el HTML inicial en el servidor. Esto significa que el contenido está disponible en el DOM antes de que se cargue y ejecute cualquier JavaScript del lado del cliente. Aunque no elimina todas las vulnerabilidades, reduce la ventana de oportunidad para ataques como XSS de ciertos tipos al no depender del JavaScript del cliente para construir el contenido inicial. Los datos sensibles procesados en el servidor se inyectan en el HTML ya 'sanitizados' por el framework si se hace correctamente.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Si bien el servidor procesa los datos sensibles, el resultado de ese procesamiento (el HTML final) se envía al cliente. La seguridad radica en cómo se manejan esos datos y se inyectan en el HTML, no en que el cliente no acceda al resultado final renderizado.","b":"SSR no elimina por completo la superficie de ataque para XSS o CSRF. Los ataques XSS aún pueden ocurrir si el contenido no se escapa correctamente antes de la hidratación o si hay vulnerabilidades en los scripts del cliente. CSRF es un problema de gestión de tokens y sesiones, no directamente abordado por SSR en sí mismo.","c":"SSR es independiente del método de autenticación. Se puede usar JWT tanto con SSR como con CSR (Client-Side Rendering). La seguridad de JWT depende de su correcta implementación (almacenamiento, caducidad, etc.), no de SSR."}},{"id":"q7","question":"Para un senior frontend, ¿cuál es el principal desafío de rendimiento al trabajar con grandes listas virtualizadas en React?","options":["a) El consumo excesivo de memoria del navegador debido a la renderización de todos los elementos a la vez.","b) La dificultad de aplicar estilos condicionales a los elementos visibles.","c) El cálculo preciso de las alturas y posiciones de los elementos visibles e invisibles para evitar saltos o parpadeos.","d) La complejidad de la gestión de eventos de clic en los elementos virtualizados."],"answer":"c","explanation":"La virtualización de listas (como `react-window` o `react-virtualized`) funciona renderizando solo los elementos visibles en la ventana de visualización. El principal desafío es el cálculo preciso de las alturas y posiciones (offsets) de los elementos, especialmente si estos tienen alturas variables, para asegurar que el scroll se comporte de manera fluida y que los elementos correctos sean renderizados y desmontados a medida que el usuario se desplaza, evitando 'jumps' visuales o contenido parpadeando.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"La virtualización se utiliza precisamente para *evitar* la renderización de todos los elementos a la vez, lo que reduciría el consumo de memoria y mejoraría el rendimiento. Esta es la solución, no el problema.","b":"La aplicación de estilos condicionales es una preocupación menor y se maneja con técnicas CSS/JS estándar, no es un desafío fundamental de la virtualización de listas.","d":"La gestión de eventos de clic no es fundamentalmente más compleja en listas virtualizadas que en listas normales; se adjuntan a los elementos que están actualmente renderizados."}},{"id":"q8","question":"¿Qué técnica de seguridad 'moderna' es esencial para proteger las APIs de un frontend contra ataques de 'brute force' o 'DDoS' en un entorno de desarrollo React?","options":["a) Implementar un CAPTCHA en cada solicitud a la API.","b) Utilizar rate limiting y mecanismos de bloqueo de IP en el lado del servidor/proxy.","c) Almacenar las credenciales de los usuarios en el LocalStorage cifradas.","d) Realizar todas las solicitudes a la API a través de WebSockets para mayor seguridad."],"answer":"b","explanation":"El rate limiting (limitar el número de solicitudes por unidad de tiempo desde una IP o usuario) y los mecanismos de bloqueo de IP (listas negras o temporales) son técnicas cruciales y efectivas implementadas en el lado del servidor o en un proxy (como un CDN o WAF) para mitigar ataques de fuerza bruta y DDoS. El frontend no puede directamente proteger la API de estos ataques de forma efectiva, solo puede ayudar a aplicar las políticas del servidor (ej. reintentos con backoff).","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Implementar un CAPTCHA en cada solicitud a la API es una mala experiencia de usuario y no es práctico para la mayoría de las APIs. Se usa selectivamente en puntos críticos como el inicio de sesión.","c":"Almacenar credenciales de usuario (incluso cifradas) en el LocalStorage es una mala práctica de seguridad porque es vulnerable a XSS. Las credenciales deben gestionarse a través de mecanismos de sesión seguros (cookies HttpOnly) o tokens JWT bien implementados.","d":"Usar WebSockets no confiere una mayor seguridad inherente contra ataques de fuerza bruta o DDoS. La seguridad de un WebSocket depende de la autenticación, autorización y las mismas medidas de rate limiting que se aplicarían a una API REST."}},{"id":"q9","question":"Considerando las 'últimas tecnologías' en React, ¿cuál es el propósito principal de `useTransition`?","options":["a) Permitir la transición de estado entre componentes sin re-renderizados.","b) Indicar a React que ciertas actualizaciones de estado pueden ser interrumpidas y pospuestas para mantener la UI responsiva.","c) Sincronizar animaciones CSS con cambios de estado de React.","d) Ejecutar efectos secundarios de forma asíncrona después de cada renderizado."],"answer":"b","explanation":"`useTransition` es un hook de concurrencia en React 18 que permite marcar ciertas actualizaciones de estado como 'transiciones'. Esto significa que React puede priorizar otras actualizaciones más urgentes (como entradas de usuario) y posponer la actualización de la transición si es necesario para mantener la UI interactiva y responsiva, evitando el bloqueo del hilo principal y mejorando la UX percibida.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"`useTransition` no previene re-renderizados; más bien, ayuda a gestionarlos y priorizarlos para que no bloqueen la UI durante actualizaciones pesadas.","c":"`useTransition` no está directamente relacionado con la sincronización de animaciones CSS. Hay librerías específicas para eso o se usa directamente CSS. Su propósito es la priorización de actualizaciones de estado.","d":"La ejecución de efectos secundarios asíncronos después de cada renderizado es el rol de `useEffect` o `useLayoutEffect`. `useTransition` se enfoca en la priorización de actualizaciones de estado."}},{"id":"q10","question":"Un senior frontend debe optimizar el tamaño del bundle de una aplicación React. ¿Qué técnica es más efectiva para reducir el tamaño inicial de carga, especialmente para rutas no visitadas inmediatamente?","options":["a) Utilizar solo componentes de clase en lugar de hooks.","b) Implementar code splitting (división de código) a nivel de ruta y componente.","c) Deshabilitar la compresión Gzip en el servidor.","d) Almacenar todos los assets en un CDN sin compresión."],"answer":"b","explanation":"El code splitting permite dividir el bundle principal de JavaScript en chunks más pequeños que se cargan a demanda, generalmente cuando el usuario navega a una ruta específica o interactúa con un componente particular. Esto reduce el tamaño del bundle inicial y mejora el tiempo de carga de la página. En React, se logra comúnmente con `React.lazy` y `Suspense`, y a nivel de rutas con librerías como `React Router`.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"El uso de componentes de clase o hooks no tiene un impacto significativo en el tamaño del bundle de esta manera. Los hooks a menudo pueden resultar en un código más conciso, lo que podría tener un impacto marginal en la reducción del tamaño.","c":"Deshabilitar la compresión Gzip (o Brotli) en el servidor aumentaría drásticamente el tamaño del bundle enviado al cliente, lo que iría en contra del objetivo de optimización.","d":"Almacenar assets en un CDN es bueno para la distribución global y la latencia, pero si no están comprimidos, su tamaño de descarga será mayor. La compresión es crucial independientemente del CDN."}},{"id":"q11","question":"¿Cuál es la implicación principal de usar 'Strict Mode' en React para el desarrollo de un senior frontend?","options":["a) Fuerza la aplicación a renderizar en el servidor para detectar errores de hidratación.","b) Ejecuta efectos y renderizados dos veces en desarrollo para ayudar a detectar efectos secundarios no deseados.","c) Deshabilita la renderización de componentes que no usan `memo` para optimizar el rendimiento.","d) Aplica automáticamente la política de seguridad 'Content Security Policy' al navegador."],"answer":"b","explanation":"El `StrictMode` de React es una herramienta de desarrollo que realiza comprobaciones adicionales y emite advertencias para ayudar a identificar problemas potenciales en la aplicación. Una de sus funcionalidades clave es que en desarrollo (y solo en desarrollo), invoca el renderizado y los efectos de `useEffect` (con su cleanup) dos veces, lo que ayuda a asegurar que los efectos no tienen efectos secundarios incontrolables y que los componentes son 'idempotentes' (producen el mismo resultado si se renderizan múltiples veces). Esto es crucial para la concurrencia y la resiliencia de la aplicación.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"`StrictMode` es una herramienta de desarrollo que funciona tanto en SSR como en CSR, y su propósito no es forzar el SSR ni detectar errores de hidratación directamente (aunque puede ayudar indirectamente al hacer el código más robusto).","c":"`StrictMode` no deshabilita la renderización de componentes ni fuerza el uso de `memo`. Su objetivo es ayudar a escribir componentes más robustos y preparados para las características concurrentes de React.","d":"`StrictMode` es una característica de React a nivel de código para el tiempo de ejecución en desarrollo, no una configuración de seguridad a nivel de navegador como la Content Security Policy (CSP), que se configura mediante encabezados HTTP."}},{"id":"q12","question":"¿Cómo se garantiza la integridad de los datos obtenidos de una API pública en una aplicación React, protegiéndose contra ataques de 'man-in-the-middle'?","options":["a) Almacenando los datos en el LocalStorage del navegador con cifrado AES-256.","b) Utilizando únicamente el protocolo HTTP para asegurar la compatibilidad con navegadores antiguos.","c) Implementando la comunicación a través de HTTPS/TLS y verificando los certificados del servidor.","d) Incluyendo un 'checksum' criptográfico en cada respuesta JSON de la API."],"answer":"c","explanation":"La principal defensa contra ataques de 'man-in-the-middle' (MiTM) para la integridad y confidencialidad de los datos en tránsito es el uso del protocolo HTTPS, que incorpora TLS (Transport Layer Security). TLS cifra la comunicación entre el cliente y el servidor y verifica la autenticidad del servidor mediante certificados digitales, asegurando que los datos no sean interceptados ni modificados durante el tránsito.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Almacenar datos sensibles en LocalStorage (incluso cifrados) no protege contra MiTM, ya que la vulnerabilidad ocurriría durante la transmisión de la información. Además, LocalStorage es vulnerable a XSS. La integridad de la comunicación es un problema de transporte, no de almacenamiento local.","b":"El uso de HTTP (sin S) deja la comunicación sin cifrar y vulnerable a MiTM, ya que los atacantes pueden interceptar, leer y modificar los datos fácilmente. HTTP es inherentemente inseguro para la mayoría de los casos de uso hoy en día.","d":"Mientras que un 'checksum' criptográfico (como un hash) puede verificar la integridad del cuerpo de la respuesta, no protege la confidencialidad de los datos en tránsito ni la autenticidad del servidor. HTTPS/TLS proporciona estas capas de seguridad de forma fundamental."}},{"id":"q13","question":"En el contexto de la 'Performance' y 'Últimas Tecnologías' en React, ¿cuál es la ventaja de la 'hidratación selectiva' (Selective Hydration) introducida en React 18?","options":["a) Permite hidratar solo los componentes que tienen interactividad y posponer el resto.","b) Carga de forma perezosa el JavaScript solo cuando el componente entra en el viewport.","c) Reduce el tamaño del bundle de JavaScript al eliminar el código no utilizado.","d) Prioriza la hidratación de componentes que tienen eventos de usuario pendientes o están cerca de ellos."],"answer":"d","explanation":"La hidratación selectiva es una característica clave de React 18 que trabaja en conjunto con la concurrencia. Permite que React hidrate partes de la aplicación de forma incremental. Más importante aún, si un usuario interactúa con una parte de la aplicación que aún no ha sido hidratada, React puede priorizar la hidratación de ese componente y sus descendientes, asegurando que las interacciones del usuario se vuelvan responsivas lo más rápido posible, incluso si el resto de la aplicación aún se está hidratando.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Aunque puede sonar similar, la hidratación selectiva no se trata de hidratar 'solo' los componentes interactivos. Se trata de cómo React puede priorizar y pausas la hidratación para mantener la interactividad donde es más necesaria.","b":"La carga perezosa de JavaScript (lazy loading) es una técnica relacionada con el code splitting, no directamente con la hidratación selectiva. La hidratación ocurre después de que el HTML y el JavaScript ya están en el cliente.","c":"La hidratación selectiva no reduce el tamaño del bundle de JavaScript. Esa es una función del code splitting o de la eliminación de código muerto. La hidratación es un proceso del lado del cliente que vincula el JavaScript al HTML pre-renderizado."}},{"id":"q14","question":"Al integrar un sistema de autenticación de terceros (OAuth/OpenID Connect) en una aplicación React, ¿cuál es la forma más segura de manejar los tokens de acceso?","options":["a) Almacenarlos en `localStorage` para fácil acceso por JavaScript.","b) Enviarlos en cada solicitud API a través de la URL como un parámetro de consulta.","c) Almacenarlos en cookies `HttpOnly` y `Secure`, accesibles solo por el servidor para protegerlos de XSS.","d) Incrustarlos directamente en el HTML de cada página para que el cliente los lea."],"answer":"c","explanation":"Almacenar tokens de acceso (especialmente tokens de sesión como JWT) en cookies `HttpOnly` y `Secure` es la práctica más segura. `HttpOnly` previene que JavaScript acceda directamente a la cookie, mitigando ataques XSS. `Secure` asegura que la cookie solo se envíe sobre conexiones HTTPS. El servidor puede leer y validar la cookie para autenticar solicitudes API, manteniendo el token fuera del alcance directo del JavaScript del cliente.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Almacenar tokens en `localStorage` los hace vulnerables a ataques XSS, donde un atacante podría robar el token y realizar solicitudes en nombre del usuario.","b":"Enviar tokens en la URL es extremadamente inseguro, ya que quedan expuestos en logs de servidor, historiales del navegador y referrers, siendo susceptibles de ser interceptados y reutilizados.","d":"Incrustar tokens directamente en el HTML es una práctica insegura y una forma de exposición pública del token, similar a la vulnerabilidad de la URL, y también los hace vulnerables a XSS si el HTML es manipulado."}},{"id":"q15","question":"¿Qué implicaciones tiene el uso de 'Suspense for Data Fetching' en la arquitectura de una aplicación React para un senior frontend?","options":["a) Permite la gestión centralizada de todo el estado de la aplicación, incluyendo datos remotos.","b) Introduce la capacidad de 'cascadear' solicitudes de datos, mejorando el rendimiento de carga inicial.","c) Requiere que la lógica de fetching de datos se mueva a componentes de orden superior o contextos globales.","d) Simplifica el manejo de estados de carga y error, permitiendo que los componentes 'esperen' por los datos de forma declarativa."],"answer":"d","explanation":"Suspense for Data Fetching (cuando se combina con librerías que implementan el patrón 'render-as-you-fetch', como React Query/TanStack Query o SWR con soporte para Suspense) permite a los componentes 'suspender' su renderizado hasta que los datos estén disponibles. Esto simplifica drásticamente el manejo de estados de carga, error y datos, ya que no se necesitan múltiples `isLoading`, `isError` o `data` checks en cada componente. El componente simplemente asume que los datos están ahí o 'suspende' y el `Suspense` fallback o `ErrorBoundary` lo maneja.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Suspense no es un gestor de estado en sí mismo; es un mecanismo para coordinar la renderización con la disponibilidad de recursos (datos, código). Requiere una fuente de datos compatible con Suspense.","b":"De hecho, 'cascadear' solicitudes (donde la solicitud B depende del resultado de A, que se resuelven secuencialmente) es un anti-patrón de rendimiento. Suspense, especialmente con soluciones de 'render-as-you-fetch', busca *evitar* la cascada de solicitudes, permitiendo que las solicitudes comiencen lo antes posible.","c":"Con Suspense, la lógica de fetching se puede acercar al componente que la necesita, ya que el componente puede 'esperar' directamente por los datos. Esto reduce la necesidad de 'prop drilling' o Contextos globales solo para pasar datos de carga."}},{"id":"q16","question":"¿Cuál es la principal razón para usar librerías de 'CSS-in-JS' (ej., styled-components, Emotion) en un proyecto React a gran escala, más allá de la estilización básica?","options":["a) Para evitar por completo el uso de CSS, reemplazándolo con JavaScript.","b) Para garantizar el aislamiento de estilos a nivel de componente y evitar colisiones de nombres CSS.","c) Para permitir que los estilos sean modificados dinámicamente por los usuarios en tiempo real.","d) Para mejorar drásticamente el rendimiento de renderizado de la aplicación."],"answer":"b","explanation":"Las librerías de CSS-in-JS sobresalen en la gestión de estilos en proyectos grandes porque resuelven el problema de la especificidad y las colisiones de nombres. Al generar clases CSS únicas o inyectar estilos directamente en el DOM, garantizan que los estilos de un componente no afecten a otros, facilitando el mantenimiento y la escalabilidad, especialmente en equipos grandes donde varios desarrolladores trabajan en diferentes partes de la UI.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"CSS-in-JS no evita el uso de CSS; de hecho, escribe CSS, pero lo hace dentro de JavaScript. Sigue siendo CSS subyacente.","c":"Aunque CSS-in-JS permite estilos dinámicos basados en props, la capacidad de los usuarios para modificar estilos en tiempo real no es su principal ventaja ni el motivo de su adopción a gran escala. Esto se puede lograr con otras técnicas también.","d":"Si bien algunas librerías CSS-in-JS tienen optimizaciones, su impacto en el rendimiento de renderizado de la aplicación en general es secundario en comparación con su principal beneficio de aislamiento de estilos. A veces, incluso pueden introducir una pequeña sobrecarga."}},{"id":"q17","question":"¿Cuál es el riesgo de seguridad principal al utilizar 'Server Components' (RSC) de React si no se implementan correctamente las capas de autenticación y autorización?","options":["a) Exposición de variables de entorno sensibles directamente al cliente.","b) Mayor superficie de ataque para ataques de 'Cross-Site Request Forgery' (CSRF).","c) Renderización de datos sensibles o contenido restringido directamente en el HTML enviado al cliente.","d) Posibilidad de que el cliente modifique el código del servidor en tiempo de ejecución."],"answer":"c","explanation":"Los React Server Components (RSC) se ejecutan en el servidor, lo que les permite acceder directamente a bases de datos o APIs internas. Si las capas de autenticación y autorización no son robustas, un atacante podría, a través de una solicitud manipulada, inducir al servidor a renderizar y enviar al cliente datos o contenido que el usuario no debería ver. El control de acceso a nivel de componente de servidor es crucial.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Si bien las variables de entorno sensibles deben manejarse con cuidado, el riesgo no es que RSC las exponga directamente al cliente, ya que el código del servidor no se envía al cliente. El riesgo está en el *resultado* de ese código (los datos).","b":"Los ataques CSRF se dirigen a las acciones del usuario, no a la renderización de componentes per se. Si bien una mala configuración de cookies o tokens puede llevar a CSRF, no es un riesgo inherente y primario de los RSC mismos, que están más centrados en la renderización de datos.","d":"El cliente no puede modificar el código del servidor en tiempo de ejecución. El código del servidor se ejecuta en el servidor. El cliente solo recibe el HTML y el JavaScript resultante."}},{"id":"q18","question":"En el contexto de 'Frontend_Senior' y 'Últimas Tecnologías', ¿cuál es la ventaja clave de usar una estrategia de 'Stale-While-Revalidate' (SWR) para la gestión de datos en React?","options":["a) Elimina la necesidad de hacer fetching de datos en el lado del cliente.","b) Proporciona una interfaz declarativa para mutar datos en el servidor sin recargar la página.","c) Mejora la experiencia de usuario mostrando datos obsoletos (stale) inmediatamente mientras se revalida la caché en segundo plano.","d) Garantiza la consistencia de datos entre múltiples clientes conectados a la misma API."],"answer":"c","explanation":"SWR es una estrategia de revalidación de caché que permite a la aplicación mostrar inmediatamente los datos que tiene en caché (incluso si están 'obsoletos' o 'stale') mientras que, en segundo plano, se realiza una nueva solicitud para revalidar esos datos con los últimos del servidor. Una vez que los datos frescos llegan, se actualiza la UI. Esto mejora drásticamente la percepción de rendimiento y la reactividad de la aplicación, ya que el usuario no ve un estado de carga mientras se espera la respuesta de la red.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"SWR (y librerías como `swr` o `react-query`) son para el fetching de datos del lado del cliente, no eliminan la necesidad de ello. De hecho, son herramientas para gestionarlo mejor.","b":"Aunque SWR/React Query ofrecen utilidades para la mutación optimista de datos (que es una forma de mutar datos sin recargar la página), la ventaja principal del patrón SWR es la forma en que gestiona el caching y la revalidación, no la mutación en sí misma.","d":"SWR ayuda con la consistencia de datos a nivel de cliente y servidor para una única aplicación. No garantiza la consistencia de datos entre múltiples clientes conectados a la misma API; eso es un problema de sincronización de estado en tiempo real (ej. WebSockets, Pub/Sub, CRDTs)."}},{"id":"q19","question":"Para mitigar ataques de 'Clickjacking' en una aplicación React que podría ser incrustada en un `iframe`, ¿qué encabezado HTTP es fundamental implementar y cómo?","options":["a) `Content-Security-Policy` con directiva `frame-ancestors`.","b) `Strict-Transport-Security` con directiva `max-age`.","c) `X-XSS-Protection` con valor `1; mode=block`.","d) `Cache-Control` con valor `no-store`."],"answer":"a","explanation":"El ataque de Clickjacking implica engañar a un usuario para que haga clic en algo que no quiere, generalmente incrustando la aplicación web en un `iframe` transparente sobre otra página. La directiva `frame-ancestors` dentro del encabezado `Content-Security-Policy` (CSP) es la forma más moderna y granular de mitigar esto, permitiendo al desarrollador controlar qué orígenes pueden incrustar el contenido en un `frame` o `iframe`. Alternativamente, `X-Frame-Options` es otra opción (DENY, SAMEORIGIN).","difficulty":"Avanzado","category":"Generated","invalidOptions":{"b":"`Strict-Transport-Security` (HSTS) fuerza el uso de HTTPS y protege contra ataques de 'downgrade', pero no contra Clickjacking.","c":"`X-XSS-Protection` es un encabezado antiguo (y a menudo ya no recomendado) que ayudaba a los navegadores a detectar y bloquear ataques XSS reflejados, pero no tiene relación con Clickjacking.","d":"`Cache-Control: no-store` evita que el navegador almacene la respuesta en caché, útil para proteger datos sensibles, pero no previene que una página sea incrustada en un `iframe`."}},{"id":"q20","question":"¿Cuál es la principal ventaja de un 'Monorepo' para un equipo senior de desarrollo frontend que gestiona múltiples aplicaciones y librerías React?","options":["a) Elimina completamente la necesidad de herramientas de gestión de paquetes como npm o yarn.","b) Permite compartir código, dependencias y configuraciones de forma más eficiente y simplifica el versionado y la refactorización a escala.","c) Aísla completamente cada proyecto, evitando cualquier acoplamiento entre ellos.","d) Reduce drásticamente el tiempo de compilación y las necesidades de recursos del CI/CD."],"answer":"b","explanation":"La principal ventaja de un monorepo para equipos grandes es la capacidad de compartir y reutilizar código (componentes, utilidades, hooks, etc.) entre diferentes aplicaciones y librerías dentro del mismo repositorio. Esto simplifica el versionado (todos los paquetes usan la misma versión o se versionan automáticamente), facilita las refactorizaciones entre proyectos interdependientes y centraliza la configuración de herramientas (ESLint, Prettier, TypeScript). Herramientas como Lerna o Nx ayudan a gestionar esta complejidad.","difficulty":"Avanzado","category":"Generated","invalidOptions":{"a":"Un monorepo sigue requiriendo herramientas de gestión de paquetes (npm, yarn, pnpm) para instalar y gestionar dependencias internas y externas. De hecho, a menudo utilizan 'workspaces' de estos gestores.","c":"Un monorepo busca precisamente lo contrario al aislamiento completo: la capacidad de compartir código. Si bien permite un cierto grado de aislamiento, su propósito es la interconexión y la reutilización controlada.","d":"Un monorepo puede aumentar la complejidad de CI/CD si no se configuran correctamente las herramientas de construcción (ej., Nx) para solo reconstruir lo que ha cambiado. Sin optimizaciones, el tiempo de compilación puede ser más largo al tener más proyectos en un solo lugar."}}]