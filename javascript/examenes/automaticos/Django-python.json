[{"id":"q1","question":"When implementing a custom authentication backend in Django, which method is typically overridden to validate user credentials, and what are its expected return values on success and failure?","options":["a) `authenticate(self, request, username, password)` returning a `User` object on success or `None` on failure.","b) `login(self, request, user)` returning `True` on success or `False` on failure.","c) `check_password(self, password)` returning `True` if valid or `False` otherwise.","d) `get_user(self, user_id)` returning a `User` object or `None`."],"answer":"a","explanation":"The `authenticate` method is the core of a custom authentication backend. It receives the request, username, and password, and its responsibility is to validate these credentials. On success, it should return the authenticated `User` object. On failure (e.g., invalid credentials), it must return `None`.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"`login` is a view function in Django's authentication system, not a method within an authentication backend for credential validation. It's used after a user has been authenticated to establish their session.","c":"`check_password` is a method typically found on a `User` model instance (or a custom user model) for comparing a given plaintext password with the hashed password stored for that user. It's used internally by authentication systems but isn't the primary method to override in a custom backend for initial credential validation.","d":"`get_user` is another method in an authentication backend, but its purpose is to retrieve a user object given a user ID, typically used by Django's session framework to re-authenticate users on subsequent requests after they've already logged in. It's not for initial credential validation."}},{"id":"q2","question":"In Django REST Framework (DRF), how does `ModelViewSet` automatically handle the generation of URLs for its associated actions (list, retrieve, create, update, destroy), and what component is essential for this automation?","options":["a) By inspecting the `queryset` attribute and inferring URL patterns based on the model name, requiring explicit `path()` definitions in `urls.py`.","b) Through `DefaultRouter` or `SimpleRouter`, which automatically register URL patterns for the `ViewSet`'s actions when passed an instance of `ModelViewSet`.","c) By using a custom `get_urls()` method within the `ModelViewSet` that generates patterns based on a predefined dictionary of actions to URL names.","d) `ModelViewSet` does not automatically handle URL generation; each action (e.g., `list`, `retrieve`) must be manually mapped to a URL in `urls.py` using `as_view()`."],"answer":"b","explanation":"Django REST Framework's `Router` classes (like `DefaultRouter` or `SimpleRouter`) are crucial for automating URL generation for `ViewSet` classes. When you register a `ModelViewSet` with a router, the router inspects the `ViewSet`'s methods (like `list`, `retrieve`, `create`, `update`, `destroy`) and automatically generates the corresponding URL patterns.","difficulty":"dificil","category":"Django-python","invalidOptions":{"a":"While `ModelViewSet` uses `queryset`, it doesn't infer URL patterns directly from it. Explicit `path()` definitions are usually needed for function-based views or `APIView`, but not for the automatic router behavior.","c":"While you can override `get_urls()` in a `ViewSet` for more control, the default, automatic behavior of `ModelViewSet`'s URL generation relies on DRF routers, not a custom `get_urls()` by default.","d":"This statement is incorrect. One of the primary benefits of `ViewSet` and `Router` in DRF is precisely to automate URL generation, reducing boilerplate code compared to using `APIView` for each action."}},{"id":"q3","question":"Consider a Django model with a `DateTimeField`. If you need to ensure that this field is automatically set to the current time only when a new object is created, but not updated on subsequent saves, which `DateTimeField` option should be used?","options":["a) `auto_now_add=True`","b) `auto_now=True`","c) `default=timezone.now`","d) `editable=False`"],"answer":"a","explanation":"The `auto_now_add=True` option for `DateTimeField` (and `DateField`) automatically sets the field's value to the current time (or date) only when the object is first created. It will not update the field on subsequent modifications to the object.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"`auto_now=True` automatically updates the field to the current time every time the object is saved, which is not the desired behavior for a creation timestamp.","c":"`default=timezone.now` (or `default=datetime.now` if `USE_TZ=False`) sets a default value when the object is created, but it does not prevent the field from being manually changed or updated later. It also wouldn't automatically update on save like `auto_now`.","d":"`editable=False` makes the field not appear in the Django admin and not be editable via forms, but it doesn't dictate whether the field is automatically set or updated by Django itself on save operations."}},{"id":"q4","question":"In Django REST Framework, when building a complex API that requires different serialization outputs for read (GET) and write (POST/PUT/PATCH) operations for the same model, what is the most idiomatic way to achieve this within a `ViewSet`?","options":["a) Override the `get_serializer_class()` method to return different serializer classes based on `self.action`.","b) Create two separate `ViewSet` classes, one for read-only operations and another for write operations, and register them independently.","c) Use conditional logic within a single `Serializer`'s `to_representation()` method to include/exclude fields based on the request method.","d) Define a `read_serializer_class` and `write_serializer_class` attribute directly on the `ViewSet`."],"answer":"a","explanation":"The most idiomatic and flexible way to handle different serializers for different actions in a DRF `ViewSet` is to override the `get_serializer_class()` method. Inside this method, you can inspect `self.action` (e.g., 'list', 'retrieve', 'create', 'update', 'partial_update') and return the appropriate serializer class for that specific action.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"While possible, creating two separate `ViewSet` classes for read and write operations on the same model is generally less efficient and violates the principle of keeping related API logic together. It also doubles the boilerplate code.","c":"Using conditional logic in `to_representation()` can work for slight variations, but it becomes cumbersome and less maintainable for significantly different field sets or nested serializer requirements. It also doesn't handle validation differences for write operations.","d":"DRF does not provide `read_serializer_class` and `write_serializer_class` attributes out of the box for `ViewSet`s. This would require custom implementation and deviates from the standard pattern."}},{"id":"q5","question":"What is the primary purpose of Django's `select_related()` and `prefetch_related()` methods, and when would you choose one over the other?","options":["a) Both are used to optimize database queries. `select_related()` is for one-to-one and many-to-one relationships (joins), while `prefetch_related()` is for many-to-many and reverse one-to-many relationships (separate queries).","b) `select_related()` performs a JOIN operation for `ManyToManyField` relationships, and `prefetch_related()` performs separate queries for `ForeignKey` relationships.","c) `select_related()` is for fetching related objects in a single query by performing subqueries, whereas `prefetch_related()` always results in multiple database queries.","d) They are interchangeable and primarily used to cache query results in memory to avoid repeated database hits."],"answer":"a","explanation":"`select_related()` is used for `ForeignKey` (many-to-one) and `OneToOneField` relationships. It performs a SQL JOIN operation, bringing all related data into a single query. `prefetch_related()` is used for `ManyToManyField` and reverse `ForeignKey` (one-to-many) relationships. It performs a separate query for each related set of objects and then performs the 'joining' in Python, avoiding multiple JOINs for large many-to-many tables.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"This statement is incorrect. `select_related()` is for `ForeignKey`/`OneToOneField` (JOIN), and `prefetch_related()` is for `ManyToManyField`/reverse `ForeignKey` (separate queries). The types of relationships are swapped in the option.","c":"`select_related()` performs a JOIN, not subqueries in the way described. While `prefetch_related()` often results in multiple queries (one for the main objects, one or more for the related objects), the key distinction is *how* they fetch and *what* types of relationships they handle best.","d":"They are not interchangeable. Their mechanisms and suitable use cases are fundamentally different based on the relationship type. While they both optimize by reducing subsequent database hits for related objects, their core functionality is not primarily caching, but efficient data retrieval from the database."}},{"id":"q6","question":"When designing a Django REST Framework API, how would you typically enforce complex object-level permissions, such as allowing a user to edit an object only if they are its owner, while still permitting read access to others?","options":["a) Implement a custom `BasePermission` class and override `has_object_permission`, registering it in `permission_classes` on the `ViewSet`.","b) Override the `get_queryset` method in the `ViewSet` to filter objects based on the requesting user.","c) Use the `IsAuthenticatedOrReadOnly` permission and add conditional logic within the serializer's `update()` method.","d) Define custom `validators` in the serializer that check user ownership during serialization."],"answer":"a","explanation":"For object-level permissions, implementing a custom `BasePermission` class and overriding its `has_object_permission(self, request, view, obj)` method is the standard and most robust approach in DRF. This method is called after `has_permission` and receives the specific object (`obj`), allowing you to inspect its owner and compare with the requesting user.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"Overriding `get_queryset` controls which objects are *visible* to the user in a list or retrieve operation, but it doesn't enforce permissions on *modifying* a specific object if its ID is known. A user could still attempt to PUT/PATCH an object they shouldn't own.","c":"`IsAuthenticatedOrReadOnly` handles class-level permissions (authenticated users for write, anyone for read). Adding conditional logic in `update()` in the serializer is possible but less declarative and harder to reuse than a dedicated permission class, especially as permissions become more complex.","d":"Custom `validators` in a serializer are primarily for validating the *data* being submitted, not for enforcing permissions based on the *existing object's state* relative to the requesting user. While a validator could theoretically check ownership, it's not the intended or idiomatic place for object-level permission enforcement in DRF."}},{"id":"q7","question":"Which of the following scenarios would most likely necessitate the use of Django's `through` model for a ManyToMany relationship?","options":["a) When you need to store additional data about the relationship itself, such as the date a user joined a group, or a custom role for a user in a project.","b) When you want to define a ManyToMany relationship where the intermediate table only stores the primary keys of the related models, without any extra fields.","c) When creating a recursive ManyToMany relationship, such as a 'friends' relationship where a user can be friends with other users.","d) When you need to optimize database queries for ManyToMany relationships by reducing the number of JOIN operations."],"answer":"a","explanation":"A `through` model (or 'intermediate model') is used in a ManyToMany relationship when you need to store additional data on the relationship itself. For example, if a `User` can be a member of multiple `Group`s, and you want to store the `date_joined` for each specific user-group membership, or `role` of the user in that group, you'd define a `UserGroupMembership` model as the `through` model.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"If you only need to store the primary keys without extra fields, a simple `ManyToManyField` without a `through` model is sufficient. Django automatically creates the intermediate table for you.","c":"Recursive ManyToMany relationships (e.g., `friends = models.ManyToManyField('self')`) do not inherently require a `through` model unless you also need to store additional data about each specific friendship (e.g., `since_date`).","d":"Using a `through` model typically *adds* complexity to queries as you now have an explicit intermediate model to navigate, rather than directly optimizing the number of JOIN operations. Query optimization for ManyToMany relationships is more often handled by methods like `prefetch_related()`."}},{"id":"q8","question":"Describe the proper use case for `F()` expressions in Django ORM queries and provide an example.","options":["a) `F()` expressions are used to perform database operations that involve referencing model field values directly within the query, preventing race conditions. Example: `Product.objects.filter(price__gt=F('cost'))`.","b) `F()` expressions are primarily used to define default values for model fields that are based on other fields in the same model. Example: `price = models.DecimalField(default=F('cost') * 1.2)`.","c) `F()` expressions enable complex SQL functions and aggregations that are not directly supported by Django's ORM. Example: `MyModel.objects.annotate(random_value=F('RANDOM'))`.","d) `F()` expressions are used to update multiple records in a single query by setting a field's value to a fixed, pre-calculated constant. Example: `MyModel.objects.update(status='processed')`."],"answer":"a","explanation":"`F()` expressions allow you to refer to a field's value directly within a database query rather than a Python value. This is crucial for performing database-level operations (like increments, comparisons between fields) and helps prevent race conditions because the operation is executed atomically by the database. The example `Product.objects.filter(price__gt=F('cost'))` correctly illustrates comparing two fields in the database.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"`F()` expressions are for query-time operations, not for defining default values in model field definitions. Default values are typically static or based on callables without direct access to other fields on the instance being created.","c":"While `F()` can be used *with* `Func` and `Expression` objects for more complex SQL, its primary purpose isn't to *enable* arbitrary SQL functions but rather to allow field-to-field operations. `F('RANDOM')` would not work directly like that; you'd likely use `Func('RANDOM')` or `Expression`.","d":"`F()` expressions are used to perform calculations or comparisons *between fields* or between a field and a value in the database. They are not for setting a field to a fixed, pre-calculated constant value across multiple records, which can be done directly with `MyModel.objects.update(field=constant_value)`."}},{"id":"q9","question":"When defining custom management commands in Django, what is the significance of the `handle()` method within a `Command` class, and what are its typical arguments?","options":["a) The `handle()` method is the entry point for the command's logic, and it typically takes `self`, `*args`, and `**options` as arguments.","b) The `handle()` method is used to define command-line arguments, and it takes `self` and `parser` as arguments.","c) The `handle()` method is responsible for setting up the Django environment, and it takes no arguments other than `self`.","d) The `handle()` method is where you declare the command's help text and name, and it only takes `self` as an argument."],"answer":"a","explanation":"The `handle()` method is the core of any custom Django management command. It's where the main logic of your command resides. It's called when the command is executed and typically receives `self`, `*args` (for positional arguments), and `**options` (for keyword arguments parsed from the command line, including those defined in `add_arguments`).","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"The `add_arguments()` method is used to define command-line arguments and takes `parser` as an argument. `handle()` is for the command's execution logic.","c":"Django's `setup()` function (often implicitly called) handles environment setup. The `handle()` method assumes the environment is already set up and focuses on the command's specific task.","d":"The command's help text (`help`) and name are typically class attributes of the `Command` class, not defined within the `handle()` method. `handle()` is for execution logic."}},{"id":"q10","question":"Explain the role of `serializers.SerializerMethodField` in Django REST Framework and when it's most appropriate to use it.","options":["a) `SerializerMethodField` is used to add a field to the serialized output whose value is computed by a method on the serializer itself, making it suitable for custom, non-model-backed data.","b) `SerializerMethodField` dynamically generates database queries based on nested relationships, reducing the need for explicit `select_related()` calls.","c) `SerializerMethodField` allows you to override existing model fields with different data types during serialization without affecting the model definition.","d) `SerializerMethodField` is primarily used for defining custom validation logic for fields that are not directly present in the model."],"answer":"a","explanation":"`SerializerMethodField` is a powerful tool in DRF for adding fields to your serialized output that don't directly correspond to a model field. Its value is determined by a method on the serializer itself (named `get_` + field name), making it ideal for calculated values, custom formatted data, or data aggregated from multiple sources that isn't stored directly in the model.","difficulty":"dificil","category":"Django-python","invalidOptions":{"b":"`SerializerMethodField` does not generate database queries or replace `select_related()`. It computes its value in Python after the model instance (and its related data, if pre-fetched) has been retrieved.","c":"While you can *represent* an existing model field differently (e.g., `created_at` as 'time ago'), its primary purpose isn't to *override* the data type but to provide a *computed representation*. For direct type conversion, you might use different field types (e.g., `DateTimeField` to `CharField`) or custom field classes.","d":"Custom validation logic for fields (model or non-model) is typically done using `validators` on the field itself, or by overriding `validate_field_name()` or `validate()` methods on the serializer. `SerializerMethodField` is for data representation, not validation."}}]