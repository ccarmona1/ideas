## JavaScript – Repaso avanzado

1. Event loop, microtasks y macrotasks
2. `this` en distintos contextos
3. Closures y scopes léxicos
4. Hoisting (`var`, `let`, `const`)
5. Prototype chain y herencia prototípica
6. Coerción de tipos (`==` vs `===`)
7. Operadores lógicos cortocircuitados
8. Memory leaks y referencias colgantes
9. Funciones puras vs efectos secundarios
10. Inmutabilidad vs mutabilidad de objetos
11. Desestructuración avanzada
12. `call`, `apply`, `bind`
13. Currying y composición de funciones
14. Spread y rest operator
15. Temporal Dead Zone

## TypeScript – Repaso avanzado

1. Tipos genéricos
2. Tipos condicionales
3. `keyof`, `typeof`, `infer`, `extends`
4. `Record`, `Partial`, `Required`, `Readonly`, `Pick`
5. `unknown` vs `any` vs `never`
6. Tipos literales y `as const`
7. Intersecciones y uniones
8. Tipos recursivos
9. Sobrecarga de funciones
10. Interfaces vs tipos (`interface` vs `type`)
11. Narrowing de tipos
12. Tipos discriminados
13. Assertion functions
14. Tipos para funciones asincrónicas
15. Módulos y tipos externos

## Node.js – Repaso avanzado

1. Event loop en Node.js
2. `cluster` y `worker_threads`
3. Streams (readable, writable, transform)
4. Buffer y manejo binario
5. Módulos: CommonJS vs ESM
6. Gestión de procesos (`child_process`, `process`)
7. Manejo de errores y `try/catch` en async/await
8. Logging estructurado y observabilidad
9. Middlewares y pipelines
10. Seguridad: inyecciones, validación y sanitización
11. Performance: profiling y benchmarking
12. Testing con mocks y spies
13. Conexiones persistentes (WebSocket, HTTP/2)
14. Uso eficiente de `Promise.all`, `Promise.race`
15. Arquitectura hexagonal / Clean Architecture

## React – Repaso avanzado

1. Hooks personalizados
2. `useEffect` y su orden de ejecución
3. Renderizado condicional y memoización
4. Context API y prop drilling
5. `useMemo` y `useCallback`
6. Suspense y `lazy` loading
7. Virtual DOM y reconciliación
8. Concurrent mode
9. Estado local vs global
10. `forwardRef` y `useImperativeHandle`
11. Testing con React Testing Library
12. SSR, CSR, SSG y rehidratación
13. Render props y patrones de composición
14. Control de formularios con `useReducer`
15. Accesibilidad (`aria`, focus management)

## Algoritmos y complejidad algorítmica

1. Big O: notación, reglas y casos típicos
2. Recursión vs iteración
3. Búsqueda binaria
4. Algoritmos de ordenamiento (merge, quick, heap)
5. Estructuras de datos (heap, trie, set, map, stack, queue)
6. Hashing y colisiones
7. Recorrido de grafos (BFS, DFS)
8. Algoritmos de caminos mínimos (Dijkstra, Floyd-Warshall)
9. Programación dinámica
10. Backtracking y ramificación
11. Sliding window
12. Two pointers
13. Divide and conquer
14. Topological sort
15. Técnicas de optimización: memoización, tabulación

## Principios y patrones de diseño de software – Repaso avanzado

1. Principios SOLID (Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion)
2. Principio DRY (Don't Repeat Yourself)
3. Principio KISS (Keep It Simple, Stupid)
4. Principio YAGNI (You Aren't Gonna Need It)
5. Principio de separación de preocupaciones (Separation of Concerns)
6. Principio de inversión de dependencias
7. Patrones de diseño creacionales (Singleton, Factory, Abstract Factory, Builder, Prototype)
8. Patrones de diseño estructurales (Adapter, Decorator, Facade, Proxy, Composite, Bridge, Flyweight)
9. Patrones de diseño de comportamiento (Observer, Strategy, Command, State, Chain of Responsibility, Iterator, Mediator, Memento, Template Method, Visitor)
10. Inyección de dependencias
11. Antipatrones comunes (God Object, Spaghetti Code, Lava Flow, Golden Hammer)
12. DDD (Domain-Driven Design) – conceptos básicos
13. Principios de diseño orientado a objetos (abstracción, encapsulamiento, herencia, polimorfismo)
14. Ley de Demeter
15. Clean Code y refactorización
