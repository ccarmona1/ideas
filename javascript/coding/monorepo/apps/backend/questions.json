[
  {
    "question": "Which of the following is true about `const` declarations in JavaScript ES6?",
    "options": [
      "a) `const` variables can be reassigned but not redeclared.",
      "b) `const` variables must be initialized at the time of declaration.",
      "c) `const` variables are hoisted to the top of their scope and initialized with `undefined`.",
      "d) `const` declarations create block-scoped variables that can be modified if they are objects or arrays."
    ],
    "answer": "b",
    "explanation": "`const` declarations require immediate initialization. They create a read-only reference to a value, meaning the identifier cannot be reassigned, though the content of mutable objects or arrays declared with `const` can be modified.",
    "invalidOptions": {
      "a": "`const` variables cannot be reassigned after their initial declaration. Attempting to do so will result in a `TypeError`.",
      "c": "`const` variables are block-scoped and, like `let`, are subject to the Temporal Dead Zone (TDZ). They are not hoisted in a way that allows access before declaration.",
      "d": "While the content of objects or arrays declared with `const` can be modified (e.g., `const arr = [1]; arr.push(2);`), the statement 'can be modified if they are objects or arrays' is only partially true; the reference itself is still immutable. The core truth about `const` is the need for immediate initialization and immutability of the binding."
    }
  },
  {
    "question": "What is the primary benefit of using `let` over `var` for variable declarations in modern JavaScript?",
    "options": [
      "a) `let` variables are automatically global, simplifying access across files.",
      "b) `let` introduces block-scoping, preventing variable leakage and redeclaration issues.",
      "c) `let` declarations are hoisted and accessible before their actual declaration line.",
      "d) `let` provides a performance boost due to optimized memory allocation."
    ],
    "answer": "b",
    "explanation": "`let` introduces block-scoping, meaning a variable declared with `let` is only accessible within the block ({}) in which it's defined. This prevents common issues like variable leakage from loops and reduces the likelihood of unintended redeclarations in larger codebases, which `var` (function-scoped) often causes.",
    "invalidOptions": {
      "a": "`let` variables are block-scoped, not global. This is the opposite of simplifying global access; it promotes more encapsulated variable usage.",
      "c": "`let` variables, while hoisted, are subject to the Temporal Dead Zone (TDZ). This means accessing them before their declaration line will result in a `ReferenceError`, making them effectively not accessible before declaration.",
      "d": "While modern JavaScript engines are highly optimized, the primary benefit of `let` over `var` is not performance but rather improved scoping rules and reduced errors due to cleaner variable management."
    }
  },
  {
    "question": "Consider the following JavaScript code snippet:\n```javascript\nconst person = {\n  name: 'Alice',\n  age: 30\n};\n\nconst { name, age: years } = person;\n\nconsole.log(name, years);\n```\nWhat will be the output?",
    "options": [
      "a) Alice 30",
      "b) name 30",
      "c) Alice years",
      "d) undefined 30"
    ],
    "answer": "a",
    "explanation": "This code uses object destructuring with aliasing. `const { name, age: years } = person;` extracts the `name` property into a variable named `name` and the `age` property into a variable named `years`. Thus, `name` will be 'Alice' and `years` will be 30.",
    "invalidOptions": {
      "b": "The `name` property's value ('Alice') is assigned to the `name` variable, not the string 'name'.",
      "c": "The `age` property's value (30) is assigned to the `years` variable, not the string 'years'. The `years` is an alias for the `age` property's value.",
      "d": "Both `name` and `age` properties exist on the `person` object, so they will be successfully destructured and assigned their respective values. Neither will be `undefined`."
    }
  },
  {
    "question": "Which of the following best describes the purpose of the rest parameter (`...`) in a JavaScript function?",
    "options": [
      "a) It allows a function to accept a fixed number of arguments as an array.",
      "b) It collects an indefinite number of arguments into an array.",
      "c) It spreads the elements of an array into individual arguments.",
      "d) It ensures that only primitive values can be passed as arguments."
    ],
    "answer": "b",
    "explanation": "The rest parameter syntax allows us to represent an indefinite number of arguments as an array. When used in a function's parameter list, it collects all remaining arguments into a single array.",
    "invalidOptions": {
      "a": "The rest parameter is for an *indefinite* number of arguments, not a fixed number. Fixed arguments are handled by regular parameters.",
      "c": "This describes the spread syntax (`...`), which is used *outside* of a function's parameter list (e.g., in array literals or function calls) to expand iterables. While they use the same `...` syntax, their purpose and context are different.",
      "d": "The rest parameter places all arguments into an array, regardless of whether they are primitive values or objects. It does not impose any type restrictions."
    }
  },
  {
    "question": "What is the key difference between `export default` and named `export` in ES6 modules?",
    "options": [
      "a) `export default` can only export functions, while named `export` can export any data type.",
      "b) A module can have multiple `export default` statements, but only one named `export` statement.",
      "c) `export default` allows you to export a single entity that can be imported with any name, whereas named `export` exports multiple entities that must be imported by their exact names.",
      "d) Named `export` is synchronous, while `export default` is asynchronous."
    ],
    "answer": "c",
    "explanation": "`export default` is used to export a single main entity from a module. When importing it, you can give it any local name (e.g., `import MyComponent from './MyModule';`). Named `export` allows you to export multiple entities (variables, functions, classes) from a module, and they must be imported using their exact names (e.g., `import { myFunction, myVariable } from './MyModule';`).",
    "invalidOptions": {
      "a": "`export default` can export any data type (objects, arrays, primitives, functions, classes), not just functions. Similarly, named `export` can also export any data type.",
      "b": "A module can only have *one* `export default` statement. It can have multiple named `export` statements.",
      "d": "Both `export default` and named `export` are part of the synchronous ES6 module loading specification. Module loading itself is synchronous for the dependency graph, although the content of modules can involve asynchronous operations."
    }
  },
  {
    "question": "Which of the following is the correct way to define a concise method in an ES6 object literal?",
    "options": [
      "a) `const obj = { myMethod: function() { /* ... */ } };`",
      "b) `const obj = { myMethod() { /* ... */ } };`",
      "c) `const obj = { 'myMethod': () => { /* ... */ } };`",
      "d) `const obj = { myMethod: () => { /* ... */ } };`"
    ],
    "answer": "b",
    "explanation": "Option b shows the concise method syntax (or method shorthand) introduced in ES6 for object literals. It allows you to omit the `function` keyword and the colon, making the syntax cleaner.",
    "invalidOptions": {
      "a": "This is the traditional way of defining a method in an object literal, not the concise method syntax introduced in ES6.",
      "c": "While functionally valid, this uses an arrow function and quotes for the key, which doesn't represent the concise method syntax. The concise method syntax is specifically for traditional function declarations within objects.",
      "d": "This uses an arrow function for the method, which is valid but not the 'concise method syntax'. The concise method syntax (`myMethod() { ... }`) specifically refers to a shorthand for regular function definitions within objects, implicitly binding `this` to the object instance (unlike arrow functions)."
    }
  },
  {
    "question": "What is a key difference between `Promise.all()` and `Promise.race()`?",
    "options": [
      "a) `Promise.all()` returns the first resolved promise, while `Promise.race()` returns all resolved promises.",
      "b) `Promise.all()` resolves when all promises in the iterable have resolved or one rejects, while `Promise.race()` resolves or rejects as soon as one of the promises resolves or rejects.",
      "c) `Promise.all()` executes promises sequentially, while `Promise.race()` executes them in parallel.",
      "d) `Promise.all()` is only for synchronous operations, `Promise.race()` is for asynchronous."
    ],
    "answer": "b",
    "explanation": "`Promise.all()` waits for all promises in the input iterable to either resolve successfully (in which case it resolves with an array of their results) or for any single promise to reject (in which case it rejects with the reason of the first rejected promise). `Promise.race()` resolves or rejects as soon as any one of the promises in the iterable resolves or rejects, adopting that promise's value or rejection reason.",
    "invalidOptions": {
      "a": "`Promise.all()` returns an array of all resolved promises' values, or the error of the first rejected. `Promise.race()` returns the value/error of the *first* promise that settles (resolves or rejects).",
      "c": "Both `Promise.all()` and `Promise.race()` execute their constituent promises in parallel. The difference lies in their resolution/rejection criteria, not their execution model.",
      "d": "Both `Promise.all()` and `Promise.race()` are designed to work with asynchronous operations represented by Promises."
    }
  },
  {
    "question": "Which statement correctly describes the behavior of `async/await`?",
    "options": [
      "a) `async` functions always return a callback, and `await` blocks the entire application until the promise resolves.",
      "b) `async` functions implicitly return a Promise, and `await` pauses the execution of the `async` function until the awaited Promise settles, without blocking the main thread.",
      "c) `async` functions are syntactic sugar for immediate synchronous execution, and `await` converts asynchronous code to synchronous.",
      "d) `async` functions use a generator under the hood, and `await` is equivalent to `.then()` chaining."
    ],
    "answer": "b",
    "explanation": "An `async` function always returns a Promise. If the function returns a non-Promise value, it will be implicitly wrapped in a resolved Promise. The `await` keyword can only be used inside an `async` function and it pauses the execution of *that specific `async` function* until the awaited Promise settles (resolves or rejects), allowing the event loop to continue processing other tasks, thus not blocking the main thread.",
    "invalidOptions": {
      "a": "`async` functions return a Promise, not a callback. While `await` pauses the function, it does so non-blocking for the main thread, allowing other JavaScript code to run.",
      "c": "`async/await` is specifically designed for asynchronous operations, making them easier to read and write, not to convert them to synchronous or execute synchronously.",
      "d": "While `async/await` can be conceptually linked to generators and offers a more synchronous-looking syntax, it's not equivalent to `.then()` chaining. It's a higher-level abstraction that makes handling promises look like synchronous code, improving readability, especially with multiple sequential asynchronous operations."
    }
  },
  {
    "question": "In React, what is the primary reason for using the `useEffect` Hook?",
    "options": [
      "a) To perform state updates that re-render the component immediately.",
      "b) To manage component-level data that changes over time.",
      "c) To handle side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.",
      "d) To optimize performance by preventing unnecessary re-renders of child components."
    ],
    "answer": "c",
    "explanation": "The `useEffect` Hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world, like fetching data from an API, setting up subscriptions, or directly manipulating the DOM. It replaces `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` from class components.",
    "invalidOptions": {
      "a": "While `useEffect` can trigger re-renders if its dependencies change and state is updated inside it, its primary purpose isn't just state updates. `useState` is for managing state directly.",
      "b": "Managing component-level data that changes over time is the role of the `useState` Hook.",
      "d": "While `useEffect` can be used in conjunction with optimizations (e.g., through its dependency array), its core purpose isn't performance optimization directly, but managing side effects. `React.memo` or `useCallback`/`useMemo` are more directly related to preventing unnecessary re-renders."
    }
  },
  {
    "question": "Which of the following statements about `useState` in React is INCORRECT?",
    "options": [
      "a) `useState` returns an array with two elements: the current state value and a function to update it.",
      "b) When updating state with `useState`, passing a new value directly (`setCount(count + 1)`) is always preferred over passing a function (`setCount(prevCount => prevCount + 1)`).",
      "c) `useState` can be called multiple times in a single functional component to manage different pieces of state.",
      "d) State updates using the setter function from `useState` are asynchronous."
    ],
    "answer": "b",
    "explanation": "When updating state that depends on the previous state (e.g., incrementing a counter), passing a function to the setter (`setCount(prevCount => prevCount + 1)`) is preferred. This ensures you're working with the most up-to-date state value, especially when updates are batched or asynchronous, preventing race conditions or stale closures.",
    "invalidOptions": {
      "a": "This statement is correct. `useState` returns `[currentState, setStateFunction]` array.",
      "c": "This statement is correct. You can manage multiple, independent pieces of state using multiple `useState` calls: `const [name, setName] = useState(''); const [age, setAge] = useState(0);`",
      "d": "This statement is correct. React batches state updates for performance, meaning they are asynchronous and don't immediately update the UI. The component re-renders after the batch of updates is processed."
    }
  },
  {
    "question": "You want to optimize a React functional component by memoizing a callback function. Which Hook would you use?",
    "options": [
      "a) `useMemo`",
      "b) `useRef`",
      "c) `useCallback`",
      "d) `useReducer`"
    ],
    "answer": "c",
    "explanation": "`useCallback` is specifically designed for memoizing callback functions. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is useful for preventing unnecessary re-renders of child components that receive the callback as a prop.",
    "invalidOptions": {
      "a": "`useMemo` is used to memoize values (computational results), not functions. While a function is a value, `useCallback` is the dedicated Hook for function memoization as it correctly handles the function's identity.",
      "b": "`useRef` is used to create a mutable `ref` object whose `.current` property can hold a value (like a DOM element or any mutable value) that persists across renders without causing re-renders.",
      "d": "`useReducer` is an alternative to `useState` for managing more complex state logic, especially when state transitions involve multiple sub-values or the next state depends on the previous one in a complex way."
    }
  },
  {
    "question": "Which of the following best describes the purpose of `useRef` in React?",
    "options": [
      "a) To create a mutable object that persists across renders without causing re-renders when its content changes.",
      "b) To manage complex state logic with a reducer function.",
      "c) To perform side effects after every render.",
      "d) To memoize expensive calculations or components."
    ],
    "answer": "a",
    "explanation": "`useRef` returns a mutable `ref` object whose `.current` property is initialized to the passed argument. The returned object will persist for the full lifetime of the component. It's commonly used to access DOM elements directly or to store any mutable value that should not trigger a re-render when changed (e.g., a timer ID, a previous value).",
    "invalidOptions": {
      "b": "Managing complex state logic with a reducer function is the purpose of `useReducer`.",
      "c": "Performing side effects after every render (or based on dependencies) is the purpose of `useEffect`.",
      "d": "Memoizing expensive calculations or components is the purpose of `useMemo` and `useCallback`."
    }
  },
  {
    "question": "What happens if you provide an empty dependency array (`[]`) to `useEffect`?",
    "options": [
      "a) The effect will run on every render of the component.",
      "b) The effect will only run once after the initial render, similar to `componentDidMount`.",
      "c) The effect will never run, as there are no dependencies to watch.",
      "d) It will cause a runtime error because `useEffect` requires dependencies."
    ],
    "answer": "b",
    "explanation": "Providing an empty dependency array (`[]`) to `useEffect` tells React that your effect does not depend on any values from props or state that change over time. Therefore, the effect will only run once after the initial render, and its cleanup function (if any) will run when the component unmounts. This is analogous to `componentDidMount` and `componentWillUnmount` in class components.",
    "invalidOptions": {
      "a": "If no dependency array is provided at all, the effect will run on every render. An empty array (`[]`) explicitly tells React to run it only once.",
      "c": "The effect will run at least once (after the initial render) even with an empty dependency array.",
      "d": "It is a valid and common pattern to provide an empty dependency array. It does not cause an error."
    }
  },
  {
    "question": "Which Node.js module is commonly used for file system operations?",
    "options": [
      "a) `http`",
      "b) `path`",
      "c) `fs`",
      "d) `url`"
    ],
    "answer": "c",
    "explanation": "The `fs` module in Node.js provides an API for interacting with the file system in a way similar to the standard POSIX functions. It includes methods for reading files, writing files, creating directories, deleting files, etc.",
    "invalidOptions": {
      "a": "The `http` module is used for creating HTTP servers and making HTTP requests.",
      "b": "The `path` module is used for working with file and directory paths, like joining path segments or extracting file extensions.",
      "d": "The `url` module is used for URL resolution and parsing."
    }
  },
  {
    "question": "In Node.js, what is the purpose of `require()`?",
    "options": [
      "a) To declare a new variable with global scope.",
      "b) To import ES6 modules into a CommonJS module.",
      "c) To synchronously load and cache modules (CommonJS format).",
      "d) To define an asynchronous function that fetches external resources."
    ],
    "answer": "c",
    "explanation": "`require()` is a built-in Node.js function used to load and cache CommonJS modules. When a module is `require()`d for the first time, it's loaded and executed, and its `exports` object is returned. Subsequent `require()` calls for the same module will return the cached `exports` object.",
    "invalidOptions": {
      "a": "`require()` is for module loading, not for variable declaration, and it doesn't automatically create global variables.",
      "b": "`require()` is for CommonJS modules. While there are transpilers or specific configurations, natively `require()` cannot directly import ES6 modules, and `import` is used for ES6 modules.",
      "d": "`require()` is synchronous. For asynchronous operations like fetching external resources, you'd typically use `fetch` (if available), `axios`, or Node's `http` module with callbacks/Promises."
    }
  },
  {
    "question": "What is the event loop in Node.js primarily responsible for?",
    "options": [
      "a) Executing synchronous JavaScript code in a multithreaded manner.",
      "b) Managing the call stack and heap for JavaScript execution.",
      "c) Handling asynchronous callbacks and I/O operations in a non-blocking way.",
      "d) Compiling JavaScript code into machine code before execution."
    ],
    "answer": "c",
    "explanation": "The Node.js event loop is a core component that allows Node.js to perform non-blocking I/O operations, despite JavaScript being single-threaded. It continuously checks the call stack for tasks, and if it's empty, it processes messages from the callback queue, which holds completed asynchronous operations' callbacks.",
    "invalidOptions": {
      "a": "Node.js JavaScript execution is single-threaded. The event loop enables concurrency, not true parallelism of JavaScript execution.",
      "b": "The call stack and heap are managed by the V8 JavaScript engine, which is part of Node.js, but the event loop's specific role is dispatching tasks, not fundamental memory management.",
      "d": "Compiling JavaScript code is handled by the V8 JavaScript engine's JIT (Just-In-Time) compiler, not the event loop."
    }
  },
  {
    "question": "Which of the following is NOT a core module in Node.js?",
    "options": [
      "a) `fs`",
      "b) `express`",
      "c) `http`",
      "d) `path`"
    ],
    "answer": "b",
    "explanation": "`express` is a popular third-party web application framework for Node.js. It needs to be installed via npm (`npm install express`), whereas `fs`, `http`, and `path` are built-in core modules that come bundled with Node.js and can be used directly without installation.",
    "invalidOptions": {
      "a": "`fs` (File System) is a core module.",
      "c": "`http` (Hypertext Transfer Protocol) is a core module for networking.",
      "d": "`path` (Path utilities) is a core module."
    }
  },
  {
    "question": "What is the purpose of `module.exports` in Node.js?",
    "options": [
      "a) To define global variables accessible throughout the application.",
      "b) To specify the main entry point of a Node.js application.",
      "c) To export values (functions, objects, primitives) from a CommonJS module so they can be imported by other modules.",
      "d) To declare a dependency on an external npm package."
    ],
    "answer": "c",
    "explanation": "`module.exports` is a special object in every CommonJS module. Whatever value is assigned to `module.exports` (or attached to its properties) becomes the public interface of that module when it's `require()`d by other files.",
    "invalidOptions": {
      "a": "While you *could* technically attach things to `global` or `process.env`, `module.exports` is specifically for defining what a *module* exports, not for global variables.",
      "b": "The main entry point of a Node.js application is typically specified in `package.json`'s `main` field, or simply by the file you execute directly with `node`.",
      "d": "Dependencies on external npm packages are declared in `package.json` under `dependencies` or `devDependencies`."
    }
  },
  {
    "question": "When defining an arrow function, what is the behavior of `this`?",
    "options": [
      "a) `this` refers to the global object (e.g., `window` in browsers, `global` in Node.js).",
      "b) `this` is dynamically bound based on how the function is called.",
      "c) `this` is lexically bound, inheriting the `this` value from its surrounding (enclosing) scope.",
      "d) Arrow functions do not have their own `this` context and it is always `undefined`."
    ],
    "answer": "c",
    "explanation": "Arrow functions do not have their own `this` binding. Instead, they inherit the `this` value from the enclosing (lexical) scope in which they are defined. This makes them very useful in callbacks where you want `this` to refer to the context where the function was created, rather than the context where it's executed.",
    "invalidOptions": {
      "a": "While `this` might default to the global object in non-strict mode for regular functions called without an explicit context, arrow functions specifically avoid this and use lexical scoping.",
      "b": "This describes the behavior of `this` in regular functions, where its value depends on how the function is invoked (e.g., method call, simple function call, `call`/`apply`/`bind`). Arrow functions explicitly deviate from this dynamic binding.",
      "d": "Arrow functions do have a `this` context; it's just inherited from the surrounding scope, not `undefined` unless the surrounding scope's `this` is `undefined`."
    }
  }
]