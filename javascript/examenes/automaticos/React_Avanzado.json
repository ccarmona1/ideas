[{"id":"q1","question":"¿Cuál de los siguientes es el caso de uso principal para `useLayoutEffect` en React, comparado con `useEffect`?","options":["a) Ejecutar efectos después de que el navegador ha pintado la pantalla, ideal para operaciones asíncronas no visuales.","b) Ejecutar efectos sincrónicamente justo después de todas las mutaciones del DOM, pero antes de que el navegador tenga la oportunidad de pintar los cambios.","c) Para prevenir re-renders innecesarios en componentes funcionales complejos, actuando como `shouldComponentUpdate`.","d) Optimizar el rendimiento de la renderización del lado del servidor (SSR) en aplicaciones React avanzadas."],"answer":"b","explanation":"`useLayoutEffect` se dispara sincrónicamente después de que React ha realizado todas las mutaciones del DOM. Esto es crucial cuando necesitas medir el DOM (por ejemplo, obtener el tamaño o la posición de un elemento) y luego realizar cambios en el DOM que deben reflejarse antes de que el navegador pinte la pantalla. Evita un posible 'flash' visual donde el usuario vería el estado sin medir antes de que se apliquen los cambios.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"`useEffect` es la hook adecuada para ejecutar efectos después de que el navegador ha pintado la pantalla, ya que es asíncrono y no bloquea el pintado del navegador.","c":"`useMemo` y `useCallback` son hooks utilizados para prevenir re-renders innecesarios o recalculaciones costosas, no `useLayoutEffect`.","d":"`useLayoutEffect` es relevante para el comportamiento del navegador y el DOM del cliente, no tiene un impacto directo en la optimización de SSR per se, aunque un DOM estable es beneficioso."}},{"id":"q2","question":"En el contexto de React Avanzado, ¿cuál es la principal ventaja de utilizar un 'custom hook' sobre una función utilitaria regular para encapsular lógica con estado?","options":["a) Los custom hooks son automáticamente memoizados por React, lo que mejora el rendimiento sin necesidad de `useMemo`.","b) Los custom hooks pueden utilizar otras hooks de React (como `useState`, `useEffect`, `useContext`), permitiendo encapsular lógica con estado y ciclo de vida.","c) Las funciones utilitarias regulares no pueden ser importadas o exportadas entre archivos, a diferencia de los custom hooks.","d) Los custom hooks permiten el uso de render props de una manera más concisa y legible."],"answer":"b","explanation":"La principal ventaja de un 'custom hook' es que te permite reutilizar lógica con estado (y efectos, y contexto) a través de componentes funcionales. Internamente, un custom hook es simplemente una función de JavaScript que utiliza otras hooks de React. Una función utilitaria regular no puede usar hooks directamente, lo que limita su capacidad para manejar estado o efectos del ciclo de vida de React.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"Los custom hooks no son automáticamente memoizados. Necesitarías usar `useCallback` o `useMemo` dentro del custom hook si quisieras memoizar funciones o valores específicos.","c":"Tanto los custom hooks como las funciones utilitarias regulares pueden ser importadas y exportadas entre archivos. Esto es una característica estándar de los módulos de JavaScript.","d":"Los custom hooks y las render props son patrones diferentes para la reutilización de lógica. Mientras que los custom hooks a menudo pueden reemplazar la necesidad de render props para ciertas situaciones, no facilitan directamente el uso de render props."}},{"id":"q3","question":"¿Qué problema resuelve principalmente la API `createContext` y `useContext` en React, y cómo se diferencia de la 'prop drilling'?","options":["a) Resuelve el problema de la sobrecarga de props al permitir el paso implícito de datos a través del árbol de componentes, evitando pasar props manualmente en cada nivel.","b) Permite que los componentes se comuniquen directamente entre sí sin pasar props, lo que es útil para el estado global y la inyección de dependencias.","c) Facilita la comunicación entre componentes hermanos sin la necesidad de un estado levantado al ancestro común.","d) Optimiza los re-renders al asegurar que solo los componentes que consumen el contexto se re-renderizan cuando el valor del contexto cambia."],"answer":"a","explanation":"El Context API de React resuelve el 'prop drilling', que es el acto de pasar props a través de muchos niveles de componentes intermedios que realmente no necesitan esos datos. Con `createContext` y `useContext`, un proveedor (`Provider`) en un nivel superior del árbol puede hacer que los datos estén disponibles para cualquier consumidor (`Consumer`) en cualquier nivel inferior del árbol, sin la necesidad de pasar las props manualmente a través de cada componente intermedio.","difficulty":"Senio","category":"Generated","invalidOptions":{"b":"Si bien permite la comunicación y es útil para el estado global, el 'paso implícito' a través del árbol es la clave, no una comunicación directa que salta la jerarquía, y sigue una estructura de proveedor/consumidor.","c":"Para componentes hermanos, generalmente se levanta el estado a su ancestro común o se utiliza un sistema de estado global como Redux. El Context API es más adecuado para pasar datos a través de una jerarquía profunda.","d":"Mientras que `useContext` puede ser más eficiente que el prop drilling en términos de concisión de código, el re-renderizado de componentes consumidores de contexto puede ser un problema si el valor del contexto cambia frecuentemente, ya que todos los consumidores se re-renderizan. Para optimizar esto, a menudo se usa `useMemo` en el valor del proveedor o se dividen los contextos."}},{"id":"q4","question":"¿Cuál es el propósito principal de `React.memo` y cuándo deberías considerar usarlo?","options":["a) Es una hook que permite memorizar funciones en componentes funcionales, evitando su recreación en cada render.","b) Es un HOC (Higher-Order Component) que memoriza un componente funcional, previniendo su re-render si sus props no han cambiado superficialmente.","c) Es una utilidad para memoizar valores computados en componentes de clase, similar a `useMemo`.","d) Se utiliza para realizar optimizaciones de rendimiento a nivel de aplicación, almacenando en caché la estructura del árbol de componentes."],"answer":"b","explanation":"`React.memo` es un HOC que puedes envolver alrededor de un componente funcional. Le indica a React que solo re-renderice ese componente si sus props han cambiado superficialmente (shallow comparison). Si las props son las mismas, React reutiliza la última renderización del componente, lo que puede ser una optimización de rendimiento útil para componentes costosos que re-renderizan con frecuencia.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"`useCallback` es la hook para memorizar funciones en componentes funcionales.","c":"`useMemo` es la hook para memorizar valores computados en componentes funcionales. Para componentes de clase, se implementaría manualmente `shouldComponentUpdate`.","d":"`React.memo` opera a nivel de componente individual, no a nivel de aplicación para almacenar en caché la estructura del árbol."}},{"id":"q5","question":"¿Cuál es la diferencia fundamental entre el 'controlador de componentes' y el 'contenedor de componentes' en React?","options":["a) Los controladores manejan la lógica de negocio y el estado, mientras que los contenedores se encargan del renderizado de la UI.","b) Los controladores son componentes de clase con estado, y los contenedores son componentes funcionales sin estado.","c) Los componentes de 'contenedor' (Container/Smart components) se encargan de la lógica, la gestión de datos y el estado, mientras que los componentes de 'presentación' (Presentational/Dumb components) se enfocan en cómo se ven las cosas y reciben datos a través de props.","d) No hay una diferencia fundamental; son términos intercambiables para describir componentes React."],"answer":"c","explanation":"La separación entre componentes 'Contenedor' y 'Presentación' (también conocidos como 'Smart' y 'Dumb' o 'Container' y 'Component') es un patrón popular en React. Los contenedores se encargan de la 'qué' (obtener datos, manejar el estado, lógica de negocio) y actúan como puentes hacia el store de Redux o el Context API. Los de presentación se encargan del 'cómo' (renderizar la UI) y son componentes puros que reciben todas sus props de un contenedor o de otro componente de presentación.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"Esto invierte los roles. Los contenedores manejan la lógica y el estado, los presentacionales el renderizado de UI.","b":"Aunque históricamente los controladores se asociaron con componentes de clase, la distinción no es sobre el tipo de componente (clase vs. funcional) sino sobre su rol y responsabilidad. Con hooks, los componentes funcionales pueden ser tanto 'smart' como 'dumb'.","d":"Existe una diferencia fundamental en su propósito y responsabilidades, lo que ayuda a organizar y mantener bases de código grandes."}},{"id":"q6","question":"Describa una situación en la que `useCallback` sería beneficioso para la optimización del rendimiento en un componente funcional de React.","options":["a) Cuando una función se pasa como prop a un componente hijo memorizado (`React.memo`), y la recreación de la función padre provocaría un re-render innecesario del hijo.","b) Para evitar que un componente funcional se re-renderice cuando su estado interno cambia.","c) Para memoizar el resultado de una computación costosa que no es una función, como un array grande o un objeto complejo.","d) Para asegurar que una función asíncrona se ejecute solo una vez durante el ciclo de vida del componente."],"answer":"a","explanation":"`useCallback` es útil cuando tienes una función que se pasa como prop a un componente hijo que está memorizado con `React.memo`. Sin `useCallback`, la función padre se recrearía en cada render del componente padre, incluso si sus dependencias no han cambiado. Esto haría que el componente hijo memorizado detectara un cambio en la prop de la función (porque es una nueva referencia), forzando un re-render innecesario. `useCallback` devuelve una versión memorizada de la función que solo cambia si sus dependencias cambian, evitando el re-render del hijo.","difficulty":"Senio","category":"Generated","invalidOptions":{"b":"`React.memo` (para componentes) o `shouldComponentUpdate` (para clases) se usan para controlar los re-renders basados en cambios de props o estado. `useCallback` es para memoizar funciones.","c":"`useMemo` se usa para memoizar el resultado de computaciones costosas (valores), no `useCallback`.","d":"`useEffect` con un array de dependencias vacío (`[]`) o con dependencias específicas se usa para controlar cuándo se ejecuta una función asíncrona (o cualquier efecto), no `useCallback`."}},{"id":"q7","question":"¿Cuál es la principal preocupación de rendimiento al usar `useContext` con un objeto como valor del contexto, y cómo se puede mitigar?","options":["a) El problema es que el objeto se clona en cada re-render, consumiendo mucha memoria. Se mitiga pasando solo tipos primitivos como valores de contexto.","b) El problema es que cada vez que el objeto del contexto cambia (incluso si sus propiedades individuales no lo hacen), todos los componentes que consumen *cualquier parte* de ese contexto se re-renderizan. Se mitiga usando `useMemo` para memoizar el objeto del contexto o dividiendo el contexto en contextos más pequeños y específicos.","c) El problema es que `useContext` realiza una comparación profunda del objeto, lo que es costoso. Se mitiga utilizando `React.memo` en los componentes consumidores.","d) El problema es que el contexto se serializa y deserializa en cada actualización. Se mitiga usando Redux para la gestión del estado global en su lugar."],"answer":"b","explanation":"Cuando un objeto (o array) es el valor de un contexto, y ese objeto se recrea en cada render del componente proveedor (aunque sus propiedades internas no hayan cambiado lógicamente, la referencia al objeto sí lo hace), React detectará un cambio en el valor del contexto. Esto provocará que *todos* los componentes que consumen ese contexto se re-rendericen, incluso si solo necesitan una pequeña parte del objeto que no ha cambiado. La mitigación común es usar `useMemo` para memoizar el objeto del contexto, asegurando que solo se recree cuando sus dependencias cambien. Otra estrategia es dividir un contexto grande en múltiples contextos más pequeños y específicos.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"El problema no es la clonación de memoria, sino la referencia del objeto y el mecanismo de re-renderizado de React. Limitarse a primitivos no es siempre práctico.","c":"`useContext` no realiza una comparación profunda. Simplemente detecta si la referencia del objeto ha cambiado. `React.memo` en los consumidores solo ayuda si las *props* del consumidor no cambian, pero el cambio de contexto forzará el re-render independientemente.","d":"El contexto no se serializa/deserializa en cada actualización. Si bien Redux puede ser una alternativa para la gestión del estado global, la mitigación específica para los problemas de rendimiento del Context API con objetos es `useMemo` y la división de contextos."}},{"id":"q8","question":"¿Cuál es el propósito de `Suspense` en React y cómo se utiliza típicamente en conjunto con `React.lazy`?","options":["a) `Suspense` permite cargar datos de forma declarativa, y `React.lazy` optimiza la carga de recursos estáticos como imágenes.","b) `Suspense` es un componente para manejar errores de componentes hijos, y `React.lazy` es para cargar fuentes de datos externas.","c) `Suspense` permite especificar un estado de carga (fallback) mientras se esperan que los componentes hijos cargados dinámicamente (`React.lazy`) o los recursos de datos (`Suspense for Data Fetching`) estén listos para renderizar.","d) `Suspense` es una API para realizar pruebas de UI asíncronas, y `React.lazy` facilita la inyección de dependencias para tests."],"answer":"c","explanation":"`Suspense` es un componente de React que te permite 'suspender' el renderizado de parte de tu UI hasta que se cumplan ciertas condiciones (por ejemplo, que el código de un componente se haya cargado o que los datos necesarios estén disponibles). Se utiliza comúnmente con `React.lazy` para la división de código (code-splitting), donde `React.lazy` permite cargar componentes dinámicamente. `Suspense` envuelve a estos componentes cargados con `React.lazy` y muestra un `fallback` (como un spinner de carga) mientras el componente real se está descargando y preparando.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"`Suspense` no es directamente para cargar datos estáticos; está más relacionado con el cargado de componentes o datos asíncronos. `React.lazy` es para componentes, no imágenes.","b":"Los 'Error Boundaries' son para manejar errores en los componentes hijos, no `Suspense`. `React.lazy` es para la carga perezosa de componentes, no fuentes de datos directamente (aunque se está desarrollando `Suspense for Data Fetching`).","d":"`Suspense` y `React.lazy` son para la gestión de UI y rendimiento en producción, no para pruebas de UI asíncronas ni inyección de dependencias para tests."}},{"id":"q9","question":"¿Cuál es la principal desventaja o consideración al usar `ReactDOM.createPortal`?","options":["a) Los eventos del DOM dentro del portal no se propagan a través del árbol de componentes de React, lo que dificulta la gestión de eventos.","b) El contenido dentro de un portal no puede acceder al contexto de React de sus componentes padre.","c) Aunque el contenido renderizado esté en un nodo DOM diferente, el árbol lógico de React permanece. Esto puede llevar a que los estilos CSS globales se apliquen inesperadamente o que la accesibilidad requiera un manejo cuidadoso.","d) Los portales solo funcionan con componentes de clase y no con componentes funcionales."],"answer":"c","explanation":"La principal consideración con los portales es que, si bien el contenido se renderiza físicamente en un nodo DOM diferente (fuera del componente padre en el árbol del DOM), lógicamente *sigue siendo parte del árbol de componentes de React del padre*. Esto significa que el contexto y los eventos se comportan como si el componente estuviera en su ubicación lógica original. Sin embargo, debido a que está en una ubicación DOM diferente, los estilos CSS (especialmente los globales o de nivel superior) pueden aplicarse de manera inesperada, y la gestión de la accesibilidad (como el orden de tabulación o las relaciones ARIA) puede requerir un manejo manual cuidadoso. Esto es particularmente relevante para modales, tooltips, etc., que suelen 'escapar' el flujo normal del DOM.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"Falso. Una de las grandes ventajas de los portales es que los eventos *sí* se propagan a través del árbol lógico de React, a pesar de que el elemento DOM esté en un lugar diferente.","b":"Falso. El contenido dentro de un portal *puede* acceder al contexto de React de sus componentes padre, ya que lógicamente sigue siendo parte del árbol de componentes de React.","d":"Falso. `createPortal` funciona perfectamente tanto con componentes de clase como con componentes funcionales."}},{"id":"q10","question":"¿Qué problema fundamental aborda `useReducer` que `useState` no puede manejar tan elegantemente en componentes React complejos?","options":["a) La imposibilidad de realizar actualizaciones por lotes de estado en `useState` para múltiples variables.","b) El manejo de lógica de estado compleja que involucra múltiples sub-valores o transiciones de estado complejas, especialmente cuando el siguiente estado depende del estado anterior.","c) La necesidad de acceder a props o estado de componentes padre dentro de un `useState`.","d) La gestión de efectos secundarios que no están directamente relacionados con el estado del componente."],"answer":"b","explanation":"`useReducer` es ideal para manejar lógica de estado compleja, especialmente cuando el estado es un objeto con múltiples campos que se actualizan de forma interdependiente, o cuando las transiciones de estado son más complejas que un simple toggle o incremento. Permite definir la lógica de actualización en un 'reducer' puro, separándola de la lógica de renderizado del componente. Esto hace que el estado sea más predecible y la lógica más testeable, similar a cómo funciona Redux. `useState` es excelente para estados simples y aislados.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"React ya realiza actualizaciones por lotes de estado para `useState` dentro de los handlers de eventos. Este no es un problema que `useReducer` resuelva exclusivamente o mejor.","c":"Ambas `useState` y `useReducer` pueden acceder a props o estado de componentes padre si se pasan correctamente a través de props o contexto.","d":"`useEffect` es la hook designada para gestionar efectos secundarios, independientemente de si se usa `useState` o `useReducer` para el estado."}},{"id":"q11","question":"En el contexto de React Router, ¿cuál es la principal diferencia entre `Link` y `NavLink`?","options":["a) `Link` realiza una recarga completa de la página, mientras que `NavLink` navega sin recargar.","b) `Link` es para navegación interna de la aplicación, y `NavLink` es para enlaces externos.","c) `NavLink` extiende `Link` y agrega la capacidad de aplicar una clase o estilo `active` automáticamente cuando la ruta actual coincide con su `to` prop, lo cual es útil para la navegación resaltada.","d) `NavLink` permite el uso de `exact` prop para hacer coincidir rutas, mientras que `Link` no."],"answer":"c","explanation":"Ambos `Link` y `NavLink` son componentes de React Router para la navegación SPA (Single Page Application) sin recargar la página. La diferencia clave es que `NavLink` es una versión especializada de `Link` que añade funcionalidades para indicar cuando está activo. Automáticamente agrega una clase CSS (por defecto `active`) o un estilo en línea cuando la ruta actual coincide con su `to` prop. Esto es ideal para barras de navegación o menús donde quieres resaltar el elemento de navegación de la página actual.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"Ambos `Link` y `NavLink` realizan navegación sin recargar la página (SPA). Los enlaces HTML (`<a>`) realizan recargas completas.","b":"Ambos son para navegación interna de la aplicación. Para enlaces externos, se usa una etiqueta `<a>` HTML estándar.","d":"La prop `exact` se utiliza con `Route` para controlar la coincidencia de rutas, no con `Link` o `NavLink`."}},{"id":"q12","question":"¿Cuál es el objetivo principal de 'Error Boundaries' en React?","options":["a) Prevenir que los componentes arrojen errores en tiempo de ejecución, envolviendo el código con un bloque `try-catch`.","b) Capturar errores de JavaScript en cualquier parte de su árbol de componentes hijo, registrarlos y mostrar una UI de fallback en lugar de que la aplicación completa se caiga.","c) Realizar un seguimiento de los errores de red y mostrar un mensaje de error al usuario cuando una solicitud falla.","d) Detectar errores en el ciclo de vida de los componentes y automáticamente intentar reiniciar el componente afectado."],"answer":"b","explanation":"Los 'Error Boundaries' (límites de error) son componentes de React (de clase, por ahora) que implementan el método de ciclo de vida `componentDidCatch(error, info)` o `static getDerivedStateFromError(error)`. Su propósito es capturar errores de JavaScript que ocurren en cualquier parte de su árbol de componentes hijo, registrarlos y, opcionalmente, mostrar una UI de fallback para que el usuario pueda seguir usando partes de la aplicación que no se vieron afectadas, en lugar de que la aplicación completa se caiga debido a un error no manejado. No capturan errores en eventos o llamadas asíncronas directamente a menos que se re-lancen.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"Los Error Boundaries no previenen que los errores ocurran; los *capturan* una vez que han ocurrido. Son como un `catch` para el árbol de componentes.","c":"Los Error Boundaries capturan errores de JavaScript durante el renderizado, en métodos del ciclo de vida y en constructores. No están diseñados para errores de red directamente, aunque un error de red podría desencadenar un error en el componente que lo maneja.","d":"Los Error Boundaries no intentan reiniciar automáticamente el componente afectado; muestran una UI de fallback y detienen la propagación del error en el árbol. La recuperación es responsabilidad del desarrollador."}},{"id":"q13","question":"¿Qué patrón se usa comúnmente en React para compartir lógica entre componentes sin recurrir a la herencia, y cómo se implementa con Hooks?","options":["a) Patrón de Singleton, implementado con `useRef` para una instancia única.","b) Patrón de Inyección de Dependencias, donde las dependencias se pasan a través de `useContext`.","c) Render Props y Higher-Order Components (HOCs); con Hooks, se reemplazan en gran medida por Custom Hooks.","d) Patrón de Observador, donde los componentes se suscriben a los cambios de estado usando `useEffect`."],"answer":"c","explanation":"Antes de los Hooks, los patrones principales para compartir lógica reutilizable en React eran 'Render Props' (pasando una función como prop que renderiza el contenido) y 'Higher-Order Components' (HOCs, que son funciones que toman un componente y devuelven un nuevo componente mejorado). Con la introducción de Hooks, los 'Custom Hooks' se han convertido en la forma preferida de encapsular y reutilizar lógica con estado y efectos, a menudo haciendo que Render Props y HOCs sean innecesarios o simplificando su implementación.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"El patrón de Singleton no es un enfoque común para compartir lógica reutilizable entre componentes en React en el sentido de cómo se comparte el comportamiento de la UI. `useRef` es para referencias mutables.","b":"La inyección de dependencias puede ser facilitada por `useContext` para pasar valores, pero no es el patrón principal para compartir *lógica* de UI o estado reutilizable de la misma manera que los Custom Hooks lo son.","d":"El patrón de Observador puede ser implementado con `useEffect` para suscripciones y desuscripciones, pero no es el patrón general para compartir lógica reutilizable de componentes de la misma manera que Custom Hooks, Render Props o HOCs."}},{"id":"q14","question":"¿Qué problema resuelve `Strict Mode` en React durante el desarrollo?","options":["a) Optimiza el rendimiento de la aplicación en producción al deshabilitar el registro de depuración.","b) Identifica patrones no seguros o APIs heredadas en tu aplicación, ejecutando efectos, constructores y métodos de actualización dos veces para detectar efectos secundarios no deseados.","c) Fuerza a todos los componentes a ser funcionales, desaconsejando el uso de componentes de clase.","d) Proporciona una interfaz para depurar componentes React directamente en el navegador, similar a las herramientas de desarrollo del navegador."],"answer":"b","explanation":"`React.StrictMode` es una herramienta que ayuda a identificar problemas potenciales en una aplicación React durante el desarrollo. No afecta la construcción de producción. Envuelve tus componentes y realiza comprobaciones y advertencias adicionales. Una de las cosas clave que hace es invocar funciones (como renderizadores de componentes, constructores, `getDerivedStateFromProps`, y funciones dentro de `useEffect` en su primera ejecución) dos veces en desarrollo para ayudar a detectar efectos secundarios no deseados o 'impurezas' en tu código que podrían causar problemas en el futuro o con características concurrentes de React.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"`Strict Mode` no tiene efecto en la producción y no optimiza el rendimiento. Es una herramienta exclusiva de desarrollo.","c":"`Strict Mode` no fuerza el uso de componentes funcionales; su propósito es más amplio y se aplica a ambos tipos de componentes (aunque muchos de sus beneficios se centran en el nuevo paradigma de Hooks).","d":"Las React DevTools son la interfaz para depurar componentes. `Strict Mode` es una herramienta de advertencia y detección de problemas."}},{"id":"q15","question":"¿Cuál de las siguientes afirmaciones sobre el 'Virtual DOM' de React es correcta?","options":["a) El Virtual DOM es una copia exacta del DOM real que se mantiene en el navegador y se actualiza en tiempo real con cada cambio de la UI.","b) El Virtual DOM es una abstracción ligera del DOM real, mantenida en memoria por React. React lo compara con el DOM real para determinar las actualizaciones más eficientes.","c) El Virtual DOM permite a React renderizar componentes directamente en el servidor sin un navegador.","d) El Virtual DOM reemplaza completamente el DOM real, lo que significa que React ya no interactúa con el DOM del navegador."],"answer":"b","explanation":"El Virtual DOM es un concepto clave en React. No es una copia directa del DOM real, sino una representación en memoria de la estructura de la UI. Cuando el estado de un componente cambia, React construye un nuevo árbol del Virtual DOM. Luego, compara este nuevo árbol con el árbol del Virtual DOM anterior y calcula las diferencias (algoritmo de 'reconciliación'). Finalmente, React actualiza solo las partes mínimas necesarias del DOM real del navegador para reflejar esos cambios, minimizando así las operaciones costosas en el DOM real y mejorando el rendimiento.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"No es una copia 'exacta' en el navegador, es una representación ligera en memoria que React controla. Y no se actualiza con 'cada cambio de UI' del navegador, sino con los cambios impulsados por React.","c":"El Virtual DOM es un concepto para la renderización del lado del cliente. La renderización del lado del servidor (SSR) utiliza diferentes mecanismos para generar HTML inicial en el servidor.","d":"Falso. El Virtual DOM *no* reemplaza el DOM real. React *interactúa* constantemente con el DOM real, pero de una manera optimizada y controlada a través del Virtual DOM y el algoritmo de reconciliación."}},{"id":"q16","question":"¿Qué patrón de diseño se utiliza comúnmente para la gestión del estado global en React cuando el Context API por sí solo no es suficiente debido a la complejidad o el rendimiento?","options":["a) Redux (o soluciones similares como Zustand, Jotai, Recoil) con un 'store' centralizado y 'reducers' para gestionar el estado de forma predecible.","b) Patrón de Módulo de Revelación para exponer solo las API necesarias para el estado.","c) Uso intensivo de `useState` y `useReducer` en el componente raíz para centralizar todo el estado.","d) Inyección de dependencias manual a través de props en cascada descendente."],"answer":"a","explanation":"Aunque el Context API es excelente para pasar datos de forma declarativa y evitar el 'prop drilling' para estados que no cambian con mucha frecuencia, para aplicaciones más grandes con estado global complejo, actualizaciones frecuentes o la necesidad de un seguimiento y depuración robustos, soluciones como Redux (y alternativas más modernas como Zustand, Jotai, Recoil) son preferidas. Estas bibliotecas ofrecen un 'store' centralizado, acciones para describir los cambios de estado y 'reducers' puros para aplicar esos cambios, lo que lleva a un flujo de datos más predecible y debuggeable.","difficulty":"Senio","category":"Generated","invalidOptions":{"b":"El patrón de Módulo de Revelación es un patrón de JavaScript para la encapsulación, pero no aborda directamente la gestión del estado global reactivo en React.","c":"Si bien es posible centralizar el estado con `useState` y `useReducer` en el componente raíz, esto puede llevar a problemas de rendimiento (re-renders masivos) y complejidad de mantenimiento para aplicaciones grandes, ya que el Context API por sí solo no tiene optimizaciones de suscripción granular.","d":"La inyección de dependencias manual a través de props es el 'prop drilling', que es precisamente lo que el Context API o las bibliotecas de gestión de estado global buscan evitar."}},{"id":"q17","question":"¿Cómo se puede optimizar el rendimiento de una lista grande y de desplazamiento rápido en React?","options":["a) Usando `React.memo` en cada elemento de la lista para prevenir re-renders innecesarios.","b) Renderizando solo los elementos visibles o casi visibles en el viewport (virtualización de listas).","c) Dividiendo la lista en múltiples componentes más pequeños para reducir la carga de renderizado.","d) Almacenando en caché los elementos de la lista en el almacenamiento local del navegador."],"answer":"b","explanation":"Para listas grandes y de desplazamiento rápido, la virtualización de listas (también conocida como 'windowing') es la técnica más efectiva. Esto significa renderizar solo un pequeño subconjunto de filas en el DOM en un momento dado, las que son actualmente visibles dentro del viewport y un pequeño búfer alrededor. Bibliotecas como `react-window` o `react-virtualized` implementan esto, reduciendo drásticamente el número de nodos DOM y el tiempo de renderizado.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"`React.memo` puede ayudar un poco, pero si la lista tiene miles de elementos, incluso con memoización, todos los elementos ocultos seguirán estando en el DOM, lo que puede causar problemas de rendimiento y memoria.","c":"Dividir la lista en componentes más pequeños no aborda el problema de tener un DOM excesivamente grande, ya que todos los componentes seguirían siendo renderizados y montados en el DOM.","d":"Almacenar en caché en el almacenamiento local ayuda con la recuperación de datos, no con el rendimiento de la renderización del DOM de una lista grande en tiempo real."}},{"id":"q18","question":"¿Qué patrón de diseño se utiliza comúnmente para manejar operaciones asíncronas y efectos secundarios en Redux?","options":["a) Redux Sagas o Redux Thunks, que son middleware que interceptan acciones y permiten la ejecución de lógica asíncrona.","b) Patrón de observador implementado directamente en los componentes de React usando `useEffect`.","c) Redux sólo permite operaciones síncronas; las asíncronas deben manejarse fuera del ciclo de Redux.","d) El uso de `async/await` directamente dentro de los `reducers` de Redux."],"answer":"a","explanation":"Redux `reducers` deben ser funciones puras y síncronas. Para manejar efectos secundarios y operaciones asíncronas (como llamadas a API), Redux utiliza middleware. Los más populares son `Redux Thunk` y `Redux Saga`. `Redux Thunk` permite que las acciones devuelvan funciones en lugar de objetos planos, lo que facilita el encadenamiento de llamadas asíncronas. `Redux Saga` es un enfoque más avanzado que utiliza generadores de ES6 para gestionar efectos secundarios complejos, ofreciendo un control más fino y testabilidad.","difficulty":"Senio","category":"Generated","invalidOptions":{"b":"Mientras que `useEffect` maneja efectos secundarios en componentes React, no es el patrón principal para manejar operaciones asíncronas *dentro del ecosistema de Redux*.","c":"Falso. Redux está diseñado para ser extensible con middleware para manejar operaciones asíncronas.","d":"Los `reducers` de Redux deben ser funciones puras y síncronas; usar `async/await` directamente en ellos es un antipatrón y conduciría a efectos secundarios no deseados y no predecibles."}},{"id":"q19","question":"¿Cuál es la diferencia entre Server-Side Rendering (SSR) y Client-Side Rendering (CSR) en el contexto de React?","options":["a) SSR significa que toda la aplicación se renderiza en el servidor y luego se envía como HTML estático, mientras que CSR renderiza en el cliente después de que el JavaScript se ha descargado.","b) SSR envía una página HTML completamente renderizada al navegador en la solicitud inicial, mejorando el SEO y el tiempo de primera pintura. CSR envía un archivo JavaScript y el navegador lo ejecuta para construir la UI dinámicamente.","c) SSR solo es posible con Next.js, mientras que CSR es el enfoque predeterminado de Create React App.","d) SSR utiliza el Virtual DOM para renderizar, mientras que CSR interactúa directamente con el DOM real."],"answer":"b","explanation":"En CSR, el servidor envía un archivo HTML mínimo y archivos JavaScript al navegador. El navegador descarga y ejecuta el JavaScript para construir dinámicamente la UI. En SSR, el servidor renderiza el componente React en HTML en el lado del servidor y envía ese HTML ya renderizado al navegador. Esto mejora la experiencia del usuario al proporcionar un contenido visible más rápido (tiempo de primera pintura) y es beneficioso para el SEO, ya que los rastreadores pueden ver el contenido completo de la página sin ejecutar JavaScript. Después de que el HTML inicial se entrega, React 'hidrata' la aplicación en el cliente, permitiendo interactividad.","difficulty":"Senio","category":"Generated","invalidOptions":{"a":"SSR envía HTML renderizado, pero la aplicación React aún necesita 'hidratarse' en el cliente para la interactividad, no es puramente estático. CSR no 'renderiza después de que el JS se ha descargado' simplemente, sino que 'construye' la UI.","c":"SSR no es exclusivo de Next.js, aunque es una de las herramientas más populares para implementarlo. Es posible implementar SSR con un setup de React personalizado o con otras herramientas. CSR es de hecho el enfoque predeterminado de CRA.","d":"Ambos SSR y CSR utilizan el Virtual DOM internamente para la lógica de renderizado y reconciliación. La diferencia radica en dónde y cuándo se genera el HTML inicial que llega al navegador."}},{"id":"q20","question":"¿Cuál es el propósito principal de `useImperativeHandle` y en qué escenarios es más útil?","options":["a) Para permitir que un componente hijo exponga un valor imperativo o métodos al componente padre, que de otro modo sería inaccesible.","b) Para manejar efectos secundarios imperativos que no encajan en el paradigma declarativo de `useEffect`.","c) Para asegurar que un componente siempre se re-renderice cuando una ref cambia, forzando la actualización.","d) Es un reemplazo moderno para los refs de string heredados en componentes de clase."],"answer":"a","explanation":"`useImperativeHandle` se utiliza con `forwardRef` para personalizar la instancia de valor que se expone a los componentes padre cuando un padre usa una `ref` para acceder al componente hijo. Su propósito principal es permitir que un componente hijo exponga un conjunto limitado de funciones o propiedades imperativas al padre, encapsulando la implementación interna y evitando que el padre acceda directamente a los detalles internos del DOM del hijo o a toda la instancia del componente. Es útil en escenarios como componentes de formulario donde necesitas, por ejemplo, un método `focus()` o `submit()` en un elemento DOM subyacente que está encapsulado dentro del componente hijo.","difficulty":"Senio","category":"Generated","invalidOptions":{"b":"`useEffect` es la hook estándar para manejar efectos secundarios declarativos. Si un efecto es 'imperativo', se suele integrar dentro de la lógica de `useEffect` con las dependencias correctas, no con `useImperativeHandle`.","c":"`useImperativeHandle` no está diseñado para forzar re-renders. La mutación de una ref no provoca un re-render por sí misma.","d":"`useRef` y `forwardRef` son los reemplazos modernos para los refs de string y los refs de callback tradicionales. `useImperativeHandle` es una hook de nicho utilizada con `forwardRef`."}}]