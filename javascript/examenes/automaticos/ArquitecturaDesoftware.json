[{"id":"q1","question":"¿Cuál es la principal diferencia entre una arquitectura monolítica y una arquitectura de microservicios en términos de despliegue y escalabilidad de software?","options":["a) La arquitectura monolítica permite despliegue y escalabilidad independiente de componentes, mientras que los microservicios no.","b) Los microservicios requieren un despliegue de la aplicación completa para cualquier cambio, a diferencia de los monolitos.","c) La arquitectura monolítica escala mejor horizontalmente que los microservicios debido a su acoplamiento.","d) Los microservicios facilitan el despliegue y la escalabilidad independiente de servicios específicos, mientras que un monolito escala toda la aplicación en conjunto."],"answer":"d","explanation":"La arquitectura de microservicios se caracteriza por descomponer una aplicación en un conjunto de servicios pequeños e independientes. Cada microservicio puede ser desarrollado, desplegado y escalado de forma autónoma. Esto contrasta con la arquitectura monolítica, donde toda la aplicación es una única unidad desplegable, lo que implica que cualquier cambio o necesidad de escalado afectará a la aplicación completa. La escalabilidad horizontal es mucho más granular y eficiente con microservicios.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"Esta afirmación es incorrecta. Es precisamente la arquitectura de microservicios la que permite el despliegue y la escalabilidad independiente de componentes, no la monolítica.","b":"Esta afirmación es falsa. Los microservicios permiten el despliegue individual de servicios, mientras que una aplicación monolítica es la que normalmente requiere un despliegue completo para cualquier cambio significativo.","c":"Esta afirmación es incorrecta. La arquitectura monolítica suele tener dificultades para escalar horizontalmente de manera eficiente para componentes específicos debido a su alto acoplamiento; los microservicios son superiores en este aspecto."}},{"id":"q2","question":"En el contexto de la Arquitectura de Software, ¿qué patrón de diseño se utiliza típicamente para desacoplar el emisor de una solicitud del receptor, permitiendo que múltiples objetos intenten manejar la solicitud de forma secuencial?","options":["a) Singleton","b) Observer","c) Chain of Responsibility","d) Strategy"],"answer":"c","explanation":"El patrón Chain of Responsibility (Cadena de Responsabilidad) permite que una solicitud sea pasada a través de una secuencia de 'handlers' o 'manejadores'. Cada handler decide si procesa la solicitud o la pasa al siguiente en la cadena. Esto desacopla el emisor de la solicitud de su receptor y permite añadir o modificar handlers dinámicamente. Es fundamental para sistemas con lógica de procesamiento condicional o jerárquica.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"El patrón Singleton asegura que una clase tenga solo una instancia y proporciona un punto de acceso global a ella. No está relacionado con el manejo secuencial de solicitudes.","b":"El patrón Observer define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente. Tampoco está relacionado con el manejo de solicitudes en cadena.","d":"El patrón Strategy permite definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. La estrategia permite que un algoritmo varíe independientemente de los clientes que lo usan. No se enfoca en el manejo secuencial de solicitudes."}},{"id":"q3","question":"¿Cuál es la principal ventaja de utilizar un enfoque Domain-Driven Design (DDD) en la arquitectura de software de sistemas complejos?","options":["a) Minimiza la necesidad de comunicación entre el equipo de desarrollo y los expertos del dominio.","b) Prioriza la eficiencia técnica sobre la comprensión profunda del negocio.","c) Facilita la creación de un modelo de software que refleja y evoluciona con el dominio del negocio, mejorando la alineación y la capacidad de respuesta a los cambios.","d) Promueve el acoplamiento fuerte entre los componentes técnicos y la lógica de negocio para un rendimiento óptimo."],"answer":"c","explanation":"Domain-Driven Design (DDD) es un enfoque para el desarrollo de software que se centra en la complejidad del dominio del negocio. Su principal ventaja es que permite construir un modelo de software robusto y expresivo que captura la esencia del negocio. Esto asegura que la aplicación resuelva problemas reales del dominio, sea más comprensible para los expertos del negocio y pueda evolucionar más fácilmente a medida que el dominio cambia. Se enfatiza la comunicación constante y la creación de un 'Ubiquitous Language' compartido entre técnicos y expertos.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"DDD requiere una comunicación constante y profunda entre el equipo de desarrollo y los expertos del dominio para construir un modelo de dominio preciso.","b":"DDD explícitamente prioriza la comprensión profunda del dominio del negocio sobre consideraciones puramente técnicas, aunque estas últimas no se ignoran.","d":"DDD busca el desacoplamiento entre diferentes partes del dominio y la lógica técnica para aumentar la modularidad y la mantenibilidad, no el acoplamiento fuerte."}},{"id":"q4","question":"En una arquitectura basada en eventos, ¿qué componente es responsable de emitir notificaciones sobre cambios de estado significativos o acciones ocurridas, sin conocimiento explícito de quién las consumirá?","options":["a) Event Consumer (Consumidor de Eventos)","b) Event Broker (Intermediario de Eventos)","c) Event Producer (Productor de Eventos)","d) Event Store (Almacén de Eventos)"],"answer":"c","explanation":"En una arquitectura basada en eventos, el 'Event Producer' (Productor de Eventos) es el componente o servicio que genera y emite eventos cuando ocurren ciertas acciones o cambios de estado dentro del sistema. Estos eventos son generalmente notificaciones de hechos pasados. El productor no necesita saber quién consumirá o reaccionará a esos eventos, lo que promueve un alto grado de desacoplamiento.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"El Event Consumer es el componente que escucha y procesa los eventos emitidos por los productores, no el que los emite.","b":"El Event Broker (también conocido como Message Broker o Event Bus) es la infraestructura que facilita el enrutamiento y la entrega de eventos desde los productores a los consumidores; no es el que genera los eventos.","d":"El Event Store es una base de datos o repositorio donde los eventos son persistidos para auditoría, rehidratación de estados o replay; no es el emisor de los eventos en tiempo real."}},{"id":"q5","question":"¿Qué patrón arquitectónico es más adecuado para sistemas donde la consistencia final es aceptable y se requiere alta disponibilidad, escalabilidad y tolerancia a fallos, a menudo lograda mediante la replicación de datos en diferentes nodos?","options":["a) Cliente-Servidor","b) Capas (Layered)","c) Event-Driven Architecture (EDA)","d) Shared Nothing Architecture (SNA)"],"answer":"d","explanation":"La Shared Nothing Architecture (SNA) es un patrón en el que cada nodo en un clúster es independiente y autónomo, con su propia CPU, memoria y almacenamiento, y no comparte recursos directamente con otros nodos. Esto permite una escalabilidad lineal, alta disponibilidad (ya que la falla de un nodo no afecta a los demás de la misma manera que en arquitecturas compartidas) y tolerancia a fallos. Es muy común en sistemas distribuidos que requieren una alta concurrencia y donde la consistencia final es una característica aceptable (ej., bases de datos NoSQL, sistemas Big Data).","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"Cliente-Servidor es un patrón básico de interacción, pero no se centra intrínsecamente en la escalabilidad distribuida, la alta disponibilidad o la consistencia final de la misma manera que SNA.","b":"El patrón de Capas es una forma de organizar la estructura interna de una aplicación para separar responsabilidades, pero no es un patrón para la arquitectura de sistemas distribuidos en cuanto a disponibilidad y escalabilidad horizontal de datos.","c":"EDA es un estilo arquitectónico que promueve el desacoplamiento a través de eventos, pero SNA describe cómo los nodos de un sistema distribuido gestionan sus recursos para lograr escalabilidad y tolerancia a fallos, y a menudo se implementa dentro de sistemas EDA, pero no es el mismo concepto."}},{"id":"q6","question":"¿Cuál es el propósito principal de un 'Boundary Context' en Domain-Driven Design (DDD)?","options":["a) Definir los límites de la interacción de la interfaz de usuario con el sistema.","b) Encapsular un modelo de dominio coherente y específico, asegurando que el significado de los términos dentro de ese contexto sea unívoco y claro, incluso si los mismos términos tienen diferentes significados en otros contextos.","c) Establecer la separación entre la capa de presentación y la capa de aplicación.","d) Delinear las fronteras técnicas de los microservicios para evitar la comunicación entre ellos."],"answer":"b","explanation":"En DDD, un Boundary Context (Contexto Delimitado) es un concepto fundamental que define un límite explícito y coherente dentro del cual un modelo de dominio particular es válido y tiene un significado específico. Dentro de un Boundary Context, el 'Ubiquitous Language' (Lenguaje Ubicuo) es consistente. Fuera de este contexto, los mismos términos pueden tener significados diferentes o no tener significado. Esto ayuda a gestionar la complejidad en sistemas grandes, dividiéndolos en subdominios manejables y evitando ambigüedades semánticas.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"Aunque puede influir en la UI, el Boundary Context no define directamente los límites de la interacción de la interfaz de usuario. Su enfoque es sobre el modelo de dominio.","c":"La separación de capas (presentación, aplicación, dominio, infraestructura) es un principio arquitectónico general, pero no el propósito específico de un Boundary Context. Este último se enfoca en el significado semántico del modelo de dominio.","d":"Los Boundary Contexts a menudo se alinean con los microservicios, pero su propósito principal no es 'evitar la comunicación', sino gestionar la coherencia del modelo de dominio. La comunicación entre Boundary Contexts se maneja a través de patrones específicos (ej., Customer-Supplier, Conformist, Anti-Corruption Layer)."}},{"id":"q7","question":"Cuando se diseña una arquitectura de microservicios, ¿qué patrón se utiliza para consolidar múltiples llamadas a microservicios backend en una única llamada desde el cliente, a menudo adaptando los datos para la interfaz de usuario específica?","options":["a) Saga","b) API Gateway","c) Circuit Breaker","d) Service Mesh"],"answer":"b","explanation":"El patrón API Gateway es un componente central en arquitecturas de microservicios que actúa como un punto de entrada unificado para todos los clientes (web, móvil, etc.). Puede manejar la autenticación, la autorización, el enrutamiento de solicitudes a los microservicios adecuados, la limitación de tasas, el almacenamiento en caché y, crucialmente, la agregación de múltiples respuestas de microservicios en una única respuesta para el cliente, adaptándola según sea necesario. Esto reduce la complejidad en el lado del cliente y las llamadas de red.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"El patrón Saga se utiliza para gestionar transacciones distribuidas en microservicios, asegurando la consistencia de datos a través de una secuencia de transacciones locales, no para consolidar llamadas al cliente.","c":"El patrón Circuit Breaker (Cortocircuito) se utiliza para prevenir que un sistema intente repetidamente una operación que falla, lo que puede sobrecargar un servicio que ya está bajo estrés. Es un patrón de resiliencia, no de agregación de llamadas.","d":"Un Service Mesh (Malla de Servicios) es una capa de infraestructura dedicada a manejar la comunicación entre servicios, proporcionando características como descubrimiento de servicios, balanceo de carga, enrutamiento, seguridad y observabilidad. Si bien es crucial para los microservicios, no es su propósito principal consolidar llamadas para el cliente, aunque pueda enrutarlas."}},{"id":"q8","question":"¿Cuál de las siguientes afirmaciones describe mejor el concepto de 'Cohesión' en el diseño de software y su impacto en la Arquitectura?","options":["a) La cohesión se refiere al grado en que los módulos de software son independientes entre sí.","b) La cohesión mide la fuerza de las relaciones entre los componentes de software, donde una cohesión alta implica dependencia mutua.","c) La cohesión es la medida de cuán relacionadas y enfocadas están las responsabilidades de los elementos dentro de un módulo, deseándose una cohesión alta para una mayor mantenibilidad y reusabilidad.","d) La cohesión se relaciona con la complejidad ciclomática de un algoritmo dentro de una función."],"answer":"c","explanation":"La cohesión es un principio de diseño de software que describe el grado en que los elementos dentro de un módulo (clase, componente, servicio) pertenecen juntos. Se considera una buena práctica de diseño tener módulos con alta cohesión, lo que significa que sus elementos están fuertemente relacionados y trabajan juntos para lograr una única responsabilidad bien definida. Una alta cohesión conduce a módulos más comprensibles, mantenibles y reusables, lo cual es fundamental para una buena arquitectura de software.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"Esta afirmación describe el acoplamiento, no la cohesión. El acoplamiento mide la interdependencia entre módulos.","b":"Esta afirmación confunde cohesión con acoplamiento. Una cohesión alta no implica dependencia mutua entre módulos, sino una fuerte relación interna dentro de un mismo módulo. El acoplamiento alto es lo que implica dependencia mutua entre módulos, y es generalmente indeseable.","d":"La complejidad ciclomática es una métrica de la complejidad interna de un algoritmo o función, no directamente del concepto de cohesión de un módulo en su conjunto."}},{"id":"q9","question":"En el contexto de la Arquitectura Evolutiva y los sistemas de software a largo plazo, ¿qué técnica se emplea para garantizar que los cambios incrementales en el código no introduzcan regresiones significativas o degraden las propiedades arquitectónicas (como rendimiento o seguridad)?","options":["a) Refactorización masiva de código legacy.","b) Utilización exclusiva de un único lenguaje de programación.","c) Gimnasia Arquitectónica (Architectural Katas).","d) Pruebas de hipótesis arquitectónicas y 'Fitness Functions' (Funciones de Aptitud)."],"answer":"d","explanation":"La Arquitectura Evolutiva (Evolutionary Architecture) se centra en permitir que la arquitectura de un sistema evolucione con el tiempo de manera controlada. Una técnica clave para esto es el uso de 'Fitness Functions' (Funciones de Aptitud), que son mecanismos automatizados o semiautomatizados que evalúan las propiedades arquitectónicas de un sistema (ej., rendimiento, seguridad, escalabilidad, mantenibilidad) con cada cambio o integración. Estas funciones actúan como un arnés de seguridad para garantizar que los cambios incrementales no degraden las cualidades no funcionales críticas, apoyando así la evolución controlada del software.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"La refactorización masiva de código legacy es una estrategia para mejorar el código existente, pero no es una técnica continua para *garantizar* la no regresión de propiedades arquitectónicas con cada cambio incremental.","b":"El uso de un único lenguaje de programación no garantiza la calidad arquitectónica ni previene regresiones. La heterogeneidad tecnológica puede ser, de hecho, una característica de arquitecturas evolutivas (ej., políglota persistencia, políglota programación).","c":"Las Architectural Katas son ejercicios de diseño para practicar y mejorar las habilidades de diseño arquitectónico, pero no son una técnica para garantizar la no regresión de propiedades arquitectónicas en un sistema de producción continuo."}},{"id":"q10","question":"Un arquitecto de software está diseñando un sistema que debe procesar grandes volúmenes de datos de eventos en tiempo real, aplicar transformaciones complejas y luego persistir los resultados. ¿Qué patrón arquitectónico distribuido sería más apropiado para este escenario, enfatizando el procesamiento de streams de datos?","options":["a) Cliente-Servidor con base de datos relacional.","b) Arquitectura de Microkernel (Plug-in).","c) Lambda Architecture o Kappa Architecture.","d) Arquitectura de capas (Layered Architecture)."],"answer":"c","explanation":"Para el procesamiento de grandes volúmenes de eventos en tiempo real con transformaciones complejas y persistencia de resultados, la Lambda Architecture y la Kappa Architecture son patrones arquitectónicos distribuidos altamente apropiados. La Lambda Architecture combina una capa de procesamiento por lotes (para precisión y re-procesamiento) y una capa de procesamiento en tiempo real (para baja latencia). La Kappa Architecture simplifica esto al utilizar una única capa de procesamiento de streams para ambos. Ambos patrones están diseñados específicamente para el procesamiento de big data en tiempo real y por lotes, utilizando tecnologías como Apache Kafka, Spark Streaming o Flink.","difficulty":"Experto","category":"Generated","invalidOptions":{"a":"Una arquitectura Cliente-Servidor con base de datos relacional no es intrínsecamente adecuada para el procesamiento de grandes volúmenes de eventos en tiempo real a escala distribuida, ya que las bases de datos relacionales pueden ser un cuello de botella y no están optimizadas para flujos de datos continuos.","b":"La Arquitectura de Microkernel (o Plug-in) se enfoca en separar la funcionalidad central de la aplicación de sus características extensibles mediante plugins. No está diseñada específicamente para el procesamiento de grandes volúmenes de datos o eventos en tiempo real en un entorno distribuido.","d":"La Arquitectura de Capas es un patrón de organización interna de una aplicación para separar responsabilidades. Si bien es fundamental para cualquier software, no aborda directamente los desafíos específicos de procesamiento de grandes volúmenes de datos en tiempo real de forma distribuida como lo hacen Lambda o Kappa."}}]